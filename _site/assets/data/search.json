[
  
  {
    "title"    : "신해나라의 2021년 회고",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2022/01/02/Reviewing_2021.html",
    "date"     : "January 2, 2022",
    "excerpt"  : "2021 연말회고\n\n\n\n작년, 재작년에도 항상 12월 31일 마지막날에 급하게 회고를 썼습니다. \n하지만 올해는 연말까지도 바쁜 일정이 계속되어 회고가 늦어버려 해를 넘기고 때늦은 회고를 남기게 되었습니다. \n\n올해는 작년, 재작년보다도 더 바쁘게 지내고 분명한 성과도 있는 해였지만 모순적이게도 성과에 만족스럽지 못해 아쉬움이 많이 남습니다.\n일단 가장 큰 문제로 한해가 시작하면서 명확한 목표설정을 하지 못했다는 점이 큰 것 같습니다. \n...",
  "content"  : "2021 연말회고\n\n\n\n작년, 재작년에도 항상 12월 31일 마지막날에 급하게 회고를 썼습니다. \n하지만 올해는 연말까지도 바쁜 일정이 계속되어 회고가 늦어버려 해를 넘기고 때늦은 회고를 남기게 되었습니다. \n\n올해는 작년, 재작년보다도 더 바쁘게 지내고 분명한 성과도 있는 해였지만 모순적이게도 성과에 만족스럽지 못해 아쉬움이 많이 남습니다.\n일단 가장 큰 문제로 한해가 시작하면서 명확한 목표설정을 하지 못했다는 점이 큰 것 같습니다. \n\n따라서 새로운 2022년에는 잊지말고 반드시 명확한 목표설정을 제일 먼저 해야할 것 같습니다.\n\n\n\n한해 요약\n\n\n\n작년과 재작년 회고와 비교해보면서 읽어보니 확실히 올해는 아쉬운 부분이 많은 것 같습니다. \n그래도 중간중간 꾸준히 무언가를 하려고 노력한 흔적이 보이긴 하는 것 같긴 한데 \n연말로 갈수록 힘이 빠지는 지 활동이 눈에띄게 저조해 졌던 것 같습니다. \n\n올 해는 유독 가정사도 많았습니다. 상반기에는 장모님 장례를 치르고 하반기에는 둘째가 태어났습니다. \n그래서 회사로부터 위로와 축하를 많이 받았고 결과적으로 휴가도 본의아니게 많이 쓴 한해가 되었습니다. \n또한 첫째는 유치원에 다니기 시작하면서 이전보다 훨씬 성장한 모습을 보였습니다. \n그런 와중에 코로나로 인해 1년 내내 재택근무를 해서 오히려 능률은 떨어지고 \n정작 책상앞에 앉아있는 시간은 더 늘어나고 감정적으로도 많이 지친 한해였습니다.\n체력적으로도 많이 부족함을 느끼고 건강 이슈도 있었던걸 반성하며 내년에는 건강도 챙겨보려고 합니다.\n\n\n\n성과\n\n주업무\n\n\n\n드디어 올해 5월 클래스노트 앱 출시를 했습니다. 🥳 🎉🎉🎉\n제 손으로 직접 처음 설계부터 시작하여 출시까지 완료한 경험이었기 때문에 무엇보다도 의미있는 성과였습니다.\n그러나 출시만 하고 이후 사업적 이슈로 인해 서비스 운영으로 이어지지 못하게 되어 아쉬움이 많이 남습니다.\n\n\n\n사이드프로젝트\n\n그 외에 사내 업무를 위한 아래 사이드프로젝트 2가지를 진행하여 업무효율을 상당히 늘릴 수 있었습니다.\n\nStringer\n\n\n  모바일 다국어 관리 프로그램\n  100% TDD 적용하여 코틀린으로 개발\n  iOS/Android 상용 프로젝트에 실제 적용하여 사용 중\n\n\nWafflePan\n\n\n  프래그먼트, 뷰모델, 레이아웃 파일 생성 프로그램\n\n\n\n\n세미나\n\n사내 세미나를 5회정도 실시했습니다만\n이전처럼 회사 전체가 아닌 팀내 공유 위주로 실시하였습니다. \n덕분에 긴 기간 준비하는 스터디 대신 단발성 세미나로만 진행하게 되었습니다. \n\n\n  Fireabase 내부배포 자동화\n  Rx키즈노트 훑어보기\n  Stringer 다국어 관리프로그램 소개\n  Unit 테스트에 대한 단상\n  for loop는 이제 그만 안녕\n\n\n아무래도 팀내 공유위주로 하다보니 부담과 준비시간이 적게 들었던 것 같습니다.\n그래도 사내세미나 했던 주제를 글로 정리하여 글또 활동과 엮은 덕분에 \n최소비용으로 최대성과를 낼수 있었던 것 같아서 이 부분은 약간 만족스럽습니다.\n\n\n\n글또\n\n\n\n올해는 상반기에는 글또5기, 하반기에는 6기 활동으로 거의 한해 내내 글또에 참여했습니다.\n그에 비해 6기때는 5기보다 참여율이 저조했는데 \n5기 활동으로 5개, 6기 활동으로 6개로 총 11개의 글을 작성하였습니다.\n한달에 한번꼴로 작성한 셈인데 아쉬움이 많이 남습니다.\n\n\n\n성장\n\n올한해 새로이 배운 기술 스택은\n\n\n   Gradle Kotlin DSL\n   Ktor &amp;amp; Kotlin-Serialzation\n   Jetpack Compose\n   Dagger &amp;amp; Hilt\n   Coroutine\n\n\n명확한 목표와 계획이 없다보니 기술스택은 거의 익히지 못해서 아쉽습니다.\n특히나 작년부터 목표로 하던 대거를 아직도 익히지 못한 점과 \n제트팩 컴포즈는 올해 좋은 기회가 있었음에도 놓친 부분이 아쉬움으로 많이 남습니다.\n\n대신이라고 하기엔 뭐하지만\nRxJava와 Clean Architecture, TDD는 실전에서 사용하면서 실력이 많이 늘어난 것 같습니다.\n\nGitHub\n\n개인 계정\n\n\n\n올해는 잔디가 너무 적었네요.\n그나마의 잔디도 주로 2주에 한번 글또 활동을 기술블로그를 작성한 것 위주인 것 같습니다.\n\n회사 계정\n\n\n\n올해는 아무래도 회사 일만 죽어라고 한 것 같습니다.\n올해는 주말에도 꽤나 일을 했군요.\n\n\n\n총평\n\n굳이 점수를 매기자면 100점 만점에 50정 정도가 되겠네요. 🤔\n불분명한 목표설정으로 인해 기대만큼의 성과를 얻지는 못했지만\n회고를 위해 정리하다보니 나름의 성과도 있고 올해도 부지런하기 위해 최선을 다했던 것 같습니다. \n아쉽고 부족했던부분은 2022년에 채우도록 반성하고 더 노력해야겠습니다.\n2021년의 해나라야 수고 많았고 고생했어.\n\n\n\n\n\n그리고 모든 영광을 밝은 모습으로 건강히 자라준 찬이와 단이에게 감사를 돌립니다.\n너무너무 사랑한다 우리 아가들\n\n\n"
} ,
  
  {
    "title"    : "Android 프로젝트에 task로 유틸 프로그램 실행하기",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin/2021/12/05/gradle_task_jar.html",
    "date"     : "December 5, 2021",
    "excerpt"  : "Jar 파일을 Gradle task로 실행하기\n\n\n\nJar 파일을 Gradle task로?\n\n유틸프로그램 또는 스크립트를 Java 또는 Kotlin으로 작성해서 \n간단한 업무 자동화를 적용해보려는 시도를 해보신 적이 있으신가요?\nKotlin DSL을 활용한다면 물론 jar 파일 없이도 코틀린을 gradle에서 실행할 수 있지만\n굳이 그러지 않더라도 별도의 jar파일로 프로젝트에 추가하여 gradle에서 task로 실행할 수 있습니다.\n\n어...",
  "content"  : "Jar 파일을 Gradle task로 실행하기\n\n\n\nJar 파일을 Gradle task로?\n\n유틸프로그램 또는 스크립트를 Java 또는 Kotlin으로 작성해서 \n간단한 업무 자동화를 적용해보려는 시도를 해보신 적이 있으신가요?\nKotlin DSL을 활용한다면 물론 jar 파일 없이도 코틀린을 gradle에서 실행할 수 있지만\n굳이 그러지 않더라도 별도의 jar파일로 프로젝트에 추가하여 gradle에서 task로 실행할 수 있습니다.\n\n어떤 식으로 활용할 수 있나요?\n저는 Google Sheet에 정리된 다국어 목록을 안드로이드 리소스 파일로 변환해주는 유틸 프로그램과\n프로젝트에서 자주 사용하는 코드 템플릿을 한꺼번에 자동으로 생성해주는 유틸 프로그램을 코틀린으로 작성하여\n해당 스크립트를 jar 파일로 실행하여 사용하고 있습니다.\njar파일 생성하는 법은 지난 포스팅 Kotlin으로 실행 가능한 JAR 파일 만들기을 참고해주세요.\n\n\n\nTask 추가하기\n\n다음은 필수 인자로 넣어줍니다.\n\n\n  태스크 이름(groovy에서는 태스크 이름, kotlin에서는 String 인자로)\n  main : 메인 메소드 위치\n  classpath : JAR 파일 위치\n\n\n그 외에 추가로 다음 인자는 옵션으로 넣어줍니다.\n\n\n  group : 태스크의 그룹. 없다면 other에 들어갑니다.\n  description : 태스크 설명.\n  args : 프로그램 인자\n\n\nGroovy인 경우 (build.gradle)\n\ntask sample_task(type: JavaExec) {\n    group = &quot;_sample_&quot;\n    description = &quot;샘플 유틸 태스크&quot;\n    classpath = files(&quot;$rootDir/Util.jar&quot;)\n    main = &#39;dev.haenara.util.MainKt&#39;\n    args = [&#39;arg1&#39;, &#39;arg2&#39;]\n}\n\nKotlin DSL 인 경우 (build.gradle.kts)\ntasks.register(&quot;sample_task&quot;, JavaExec::class) {\n    group = &quot;_sample_&quot;\n    description = &quot;샘플 유틸 태스크&quot;\n    classpath = files(&quot;$rootDir/Util.jar&quot;)\n    main = &quot;dev.haenara.util.MainKt&quot;\n    args = listOf(&quot;arg1&quot;, &quot;arg2&quot;)\n}\n\n\n위와 같이 \n만약에 Path에 /를 넣어서 윈도우에서 동작하지 않는다면 아래와 같이 path를 사용하여 해결합니다.\n단 함수위에 Experimental 어노테이션을 추가해야한다.\n\n@OptIn(ExperimentalPathApi::class)\ntasks.register(&quot;sample_task&quot;, JavaExec::class) {\n    ...\n    classpath = files(path(rootDir) { this / &quot;Util.jar&quot; })\n    ...\n}\n\n\n예제 실행\n\n\n\ngradle 탭에 다음과 같이 Task가 생성된 것을 확인할 수 있습니다.\n"
} ,
  
  {
    "title"    : "Android 앱에서 ADB 연결 막기",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin/2021/12/05/adb_detect.html",
    "date"     : "December 5, 2021",
    "excerpt"  : "ADB와 보안\n\n\n\nADB란?\n\nADB는 Android Debug Bridge의 약자로 \n개발자가 안드로이드 디버깅을 위해 단말에 USB 또는 TCP프로토콜로 연결하여 사용하는 \n디버깅용 툴 프로그램 입니다.\n\nADB를 이용하여 다양한 명령어 조작과 shell 스크립트 동작을 사용할 수 있어서\n경우에 따라서는 안드로이드 앱에서 여러가지 보안 정책을 보안상의 이유로 ADB 연결을 막는 경우가 있습니다. \n보통은 크게 신경쓰지 않지만 일부 높...",
  "content"  : "ADB와 보안\n\n\n\nADB란?\n\nADB는 Android Debug Bridge의 약자로 \n개발자가 안드로이드 디버깅을 위해 단말에 USB 또는 TCP프로토콜로 연결하여 사용하는 \n디버깅용 툴 프로그램 입니다.\n\nADB를 이용하여 다양한 명령어 조작과 shell 스크립트 동작을 사용할 수 있어서\n경우에 따라서는 안드로이드 앱에서 여러가지 보안 정책을 보안상의 이유로 ADB 연결을 막는 경우가 있습니다. \n보통은 크게 신경쓰지 않지만 일부 높은 보안수준이 요구되는 금융앱의 경우\n실제로 이 ADB 연결을 막기도 합니다.\n\n\n\n\n  실제 부산은행 썸뱅크 앱에서 ADB 연결시 나오는 메세지\n\n\n사실 원리는 간단합니다.\n\nUSB연결 여부와 USB디버깅 모드가 켜져있는지 두가지를 확인하는 방법입니다.\n\n\n\n1. 👷 USB 디버깅이 켜져있는지 확인하는 방법\n\n안드로이드 세팅에 USB 디버깅 모드가 켜져있는지 여부를 가지고 있습니다.\nandroid api 16 이하에서는 아래와 같은 방법으로 확인할 수 있습니다.\n\n// 아래 값이 0이 아니면 개발자 모드가 켜진 것이다.\nSettings.Secure.getInt(context.contentResolver, Settings.Secure.ADB_ENABLED, 0)\n\n\n\nandroid api 17 부터는 아래와 같은 방법으로 확인해야 합니다.\n\n// 아래 값이 0이 아니면 개발자 모드가 켜진 것이다.\nSettings.Secure.getInt(context.contentResolver,Settings.Global.ADB_ENABLED, 0)\n\n\n즉 정리하면 아래와 같이 됩니다.\n\n/**\n * 개발자모드에서 USB디버깅이 허용되어 있는지 확인\n * @param context\n * @return\n */\nfun isDebugEnable(): Boolean {\n    return when {\n        Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN -&amp;gt; Settings.Secure.getInt(\n            mContext.contentResolver,\n            Settings.Secure.ADB_ENABLED, 0\n        ) != 0\n        Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 -&amp;gt; Settings.Secure.getInt(\n            mContext.contentResolver,\n            Settings.Global.ADB_ENABLED, 0\n        ) != 0\n        else -&amp;gt; false\n    }\n}\n\n\n\n\n2.  🔌 USB 연결이 되어있는지 확인하는 법\n\nUSB가 연결되어 있는지 확인하는 방법은 아래와 같이 인텐트 필터를 이용합니다.\n\n/**\n * USB 연결이 되어있는지 확인\n * @param context\n * @return\n */\nprivate fun isUsbConnected(): Boolean {\n    val intent = context.registerReceiver(\n        null,\n        IntentFilter(&quot;android.hardware.usb.action.USB_STATE&quot;)\n    )\n    return intent != null &amp;amp;&amp;amp; intent.extras != null &amp;amp;&amp;amp;\n            intent.extras!!.getBoolean(&quot;connected&quot;)\n}\n\n\n따라서 USB가 연결되어 있고 USB 디버깅 모드가 허용되어 있다면\nUSB 디버깅을 하고 있다는 뜻 입니다.\n\n/**\n* USB연결 정책 위반 여부 확인\n* USB 연결 여부, USB디버깅설정 여부 모두 true 면 true\n* @return\n*/\nfun checkUsbDebuggingMode(): Boolean {\n    return isDebugEnable() and isUsbConnected()\n}\n\n\n\n\n3. ⚡ USB 연결을 감지\n\n위 방법을 이용하면 USB가 연결되어 있는지 그 순간에만 확인할 수 있고\n앱 실행 중에  USB가 연결되는 것은 확인할 수 없습니다.⚡\n\n앱 실행 중 USB가 연결되는 것을 확인하려면 BroadcastReceiver를 등록하여 \n하드웨어에서 USB가 연결된 이벤트를 받아서 처리할 수 있습니다.\n\n단 USB가 연결되었을 때 USB 디버깅이 켜져있는지 먼저 확인해야 합니다.\nUSB 연결을 감지하는 BroadcastReceiver 의 코드 예제는 아래와 같습니다.\n\n/**\n * USB 디버깅을 방지하기 위한 클래스\n * release 빌드에서 USB가 연결되고 개발자모드의 USB디버깅(ADB)이 허용되어 있으면\n * 앱을 강제로 종료하는 리시버 클래스\n */\nclass UsbDebugReceiver : BroadcastReceiver() {\n    // 하드웨어 이벤트 감지시 onReceive 가 실행\n    override fun onReceive(context: Context, intent: Intent) {\n        // USB디버깅 모드가 허용되어 있는지 확인한다. \n        val adbEnabled = AdbDetector(context).checkUsbDebuggingMode()\n        intent.extras?.let {\n            if (it.getBoolean(&quot;connected&quot;) &amp;amp;&amp;amp; adbEnabled) {\n                // USB 디버깅이 감지되었으므로\n                // 여기에서 이후 처리를 하면 된다.\n            }\n        }\n    }\n}\n\n\n\n\n  ⚠️⚠️⚠️주의할 점⚠️⚠️⚠️\n이 USB 이벤트는 수초 안에 여러번 발생하는 경우가 있으니\n방어코드를넣지 않으면 여러번 실행될 수 있습니다!!!\n\n\n리시버를 실제 Application 또는 Activity 에서 등록하는 코드는 아래와 같습니다.\n\n// USB 연결을 감지하는 필터를 등록\nval filter = IntentFilter()\nfilter.addAction(&quot;android.hardware.usb.action.USB_STATE&quot;)\ncontext.registerReceiver(UsbDebugReceiver(), filter)\n\n\n\n\n  ⚠️⚠️⚠️주의할 점⚠️⚠️⚠️\n어떤 동작을 할 건지에 따라 Foreground 에 있을 때만 동작하고\nBackground로  내리갈 땐 리시버 해지가 필요할 수도 있습니다.\n앱을 강제 종료하는 액티비티 실행과 같은 액션일 경우\n실행중이지 않고 백그라운드에 있는데 강제 종료 액티비티가 실행되는 등\n불필요한 액션이 발생할 수 있습니다.\n\n\n\n\n4. 🚀 예제 실행\n\n\n\nUSB을 연결하자 마자 다이얼로그를 띄우고 앱을 종료시켜버립니다.\n\n\n\n5.  📝 소스코드와 예제\n\n소스코드와 예제는 아래 URL에서 확인하실 수 있습니다.\n\n\n\nhttps://github.com/HaenaraShin/AdbDetector\n\n6.  🎬 그리고 반전…\n\n이제와서 반전은…\n사실 앱수준에서 근본적인 레벨에서 ADB를 막을 방법은 없습니다.\n왜냐면 지금까지 설명한 것은 USB연결을 통한 ADB는 막을 수 있어도\nWiFi를 통한 무선 ADB 연결을 막을 수는 없기 때문입니다..!!😱😱😱\n이 때문에 사실 USB 디버깅은 대부분 신경 쓰지 않습니다….\n\n\n다만 일전에 취약점 점검을 위해 모바일 앱 모의해킹을 진행한 적이 있는데\n담당자가 WiFi ADB를 모르는 사람이었습니다. (100% 실화)\n\n따라서 꼭 의미 없는 것만은 아닐지도 모르겠습니다. \n"
} ,
  
  {
    "title"    : "진보 개발자, 보수 개발자",
    "category" : "",
    "tags"     : " ",
    "url"      : "/developer/2021/11/07/jb.html",
    "date"     : "November 7, 2021",
    "excerpt"  : "진보 개발자? 보수 개발자?\n\n오랜만에 다시 글을 쓰는 기념으로 오늘은 좀 가벼운 주제를 다뤄볼까 합니다.\n개발자들에게도 진보/보수가 나뉜다는 사실 들어보셨나요?\n이번 기회에 스스로의 성향과 주변 팀원들의 성향을 한번 파악해보시는 것도 재밌을 것 같습니다.\n\n\n\n여기서 진보 보수는 정치의 진보 보수와는 전혀 관계 없고 소스코드를 대하는 자세에 가깝습니다. \n이 진보/보수 급진/온건 네가지 개념은 어디 근거있는 이야기는 아니고\n제가 개인적으...",
  "content"  : "진보 개발자? 보수 개발자?\n\n오랜만에 다시 글을 쓰는 기념으로 오늘은 좀 가벼운 주제를 다뤄볼까 합니다.\n개발자들에게도 진보/보수가 나뉜다는 사실 들어보셨나요?\n이번 기회에 스스로의 성향과 주변 팀원들의 성향을 한번 파악해보시는 것도 재밌을 것 같습니다.\n\n\n\n여기서 진보 보수는 정치의 진보 보수와는 전혀 관계 없고 소스코드를 대하는 자세에 가깝습니다. \n이 진보/보수 급진/온건 네가지 개념은 어디 근거있는 이야기는 아니고\n제가 개인적으로 예전부터 생각하던 생각이니 그냥 재미로 보시면 되겠습니다.\n가벼운 마음으로 보면서 나는 진보 개발자인지 보수 개발자인지 한번 구별해보시기 바랍니다.\n\n\n\n진보와 보수를 나누는 기준\n\n기존의 소스코드를 개선/수정하려는 성향이 강하면 진보에 가깝고\n반대로 기존의 소스코드와 구조를 보존/유지하려는 성향이 강하면 보수에 가깝다고 보시면 됩니다.\n\n이렇게 설명하면 당연히 진보가 좋은거 아닌가?🤔 하는 생각이 드실 수 있습니다.\n그러나 `리팩토링이 오히려 새로운 버그를 만들거나 기존의 기능이 제대로 동작하지 않는 등 항상 성공적인 결과를 도출하지는 않습니다.\n그런 점을 감안해 본다면 리팩토링은 신중하게 접근해야할 필요가 있습니다.\n\n\n진보의 문제라고 한다면 리팩토링에 리스크를 과소평가한다는 점이 있습니다.\n정작 새로운 기능을 추가하는 것이 아니기 때문에 설령 앞으로의 능률이 좋아지거나 잔존 버그를 처리했다 하더라도\n그 소스코드를 만지지 않는 다른 파트의 직원이나 상사(혹은 대표)가 보았을 땐 안해도 크게 상관없는 작업으로 보일 수 있습니다.\n\n\n반대로 보수 개발자는 어떤의미로는 SW개발자와는 본질적으로 모순 되는 존재입니다.\n다들 아시겠지만 SW의 의미 자체가 고치기 어려운 HardWare의 반대인 유연하고 수정이 쉬운 SoftWare 입니다. \n이미 SW의 본질이 ‘수정과 유지보수’라는 의미를 내포하고 있는데 정작 이 수정대신 보존에 더 의미를 둔다면\n본질적으로 모순된다고도 할 수 있는 셈입니다.\n\n\n\n제가 존경하는 개발자분이 해주신 말씀에 따르면 레거시란\n\n\n  ‘어제 짜도 문제가 있다면 그게 레거시’\n\n\n라고 합니다.\n\n진보는 이 문장을 보고 ‘어제 작성한 코드도 레거시다’ 라고 받아들이고\n보수는 이 문장을 보고 ‘문제만 없으면 레거시는 없다’ 라고 받아들입니다. \n\n\n\n급진과 온건을 나누는 기준\n\n급진과 온건은 딱 이거다! 라고 나누기는 어렵지만\n팀원 혹은 스스로와 타협이 충분히 잘 이루어진다면 온건에 가깝다고 할 수 있고\n코드를 보고 있는데 보존/수정하는 것이 스스로 용서가 안된다던가 팀원과 이런 문제로 갈등을 겪어보셨다면 급진일 확률이 높습니다.\n\n보통 온건이신 분들은 팀워크에 중점을 두고\n급진이신 분들은 엔지니어로서의 자긍심을 두는 경향이 있는 것 같습니다.\n\n개발자를 진보/보수 개발자로 만드는 것\n\n아무래도 오래되고 레거시가 큰 프로젝트 일수록 아무래도 개발자를 보수적으로 접근하게 만들고\n새로운 프로젝트거나 규모가 작은 프로젝트 일수록 진보적으로 만드는 경향이 있습니다. \n(물론 예외는 언제나 있기 마련입니다.)\n\n팀 문화에 따라서도 좀 수평적인 분위기일수록 진보성향의 개발자가 많을 확률이 높아지는 부분도 있습니다.\n\n또 재밌는 점은 연차에 따른 차이도 있는데\n연차가 높아질수록 보수적으로 변하는 부분도 어느정도 있지만\n보통 신입(0년차)-&amp;gt;초급(1~2년차)로 넘어가는 단계나 주니어(3년미만)에서 중니어(3~5년차) 개발자로 넘어가는 과정처럼\n계단식으로 한단계씩 성장하는 과정에서 갑자기 진보적으로 변하는 경우가 종종 있습니다.\n솔직히 저도 비슷한 시기에 진보적으로 변했던 경험이 있습니다. \n아마 스스로 성장하는 과정에서 겪는 사춘기와 같은 자연스러운 형상이라고 생각합니다.\n\n\n다만 이런 것이 나쁜 것은 아니지만 이런 과정에서 만약 디자인패턴 책을 처음 읽고 너무 감명깊게 읽었다던가, \n개발자 컨퍼런스에서 너무 획기적인 영감을 얻어서 갑작스럽게 리팩토링을 시작하신다면 조금 신중하게 결정하시기를 권합니다.\n책을 안읽은 사람보다 한권만 읽은 사람이 무섭다고들 하지요…. ㅎㅎㅎ\n\n\n\n가장 중요한 것은 책임감과 테스트\n\n한국말은 언제나 마지막이 중요하드시 오늘의 글도 지금부터가 핵심입니다.\n이 글에서 가장 중요한 것은 리팩토링을 하느냐 vs 레거시를 보존하느냐 의 싸움이 아니라\n어찌됐든 그 소스코드를 보고 있는 당신이 (설령 작성자가 아닐지라도) 그 코드의 책임을 져야한다는 것입니다.\n\n제 인생에서 가장 경멸하던 개발자는 급진/진보에 가까운 성향이었는데\n코드를 몽땅 뜯어고쳐놓고 제대로된 테스트조차 돌려보지 않아서 수많은 버그와 함께 롤백한 사례를 본 적이 있습니다.\n그렇다고 보수개발자가 문제가 없냐고 하면 또 그건 아닌게 보수개발자들은 보통 퇴사하고 한두달 뒤에 지뢰가 터지곤 합니다.\n결국 레거시가 들고있는 문제들을 후임자들에게 떠넘기게 되는 결과로 이어질 수도 있습니다.\n\n그럼 잘 책임진다는 것은 어떤 것을 의미할까요?\n저는 꼼꼼한 테스트와 그것을 테스트코드 혹은 문서로 잘 남기는 것을 의미한다고 생각합니다.\n제가 개인적으로 존경하던 개발자중에 급진/진보와 급진/보수 개발자가 모두 있었는데\n두분의 공통점은 결국 그분들이 담당한 프로젝트에서 문제가 발생하지 않았다는 점이고\n기존 레거시의 문제를 꼼꼼한 테스트코드 혹은 체계화되고 상세한 문서화를 통해 다음 후임자가 그대로 물려받지 않도록 했다는 점입니다. \n\n\n\n결론적으로 리팩토링이냐 보존이냐를 두고 어느게 우선인지 따지는 대신\n테스트 코드는 잘 작성되어 있는지, 문서화는 꼼꼼히 잘 되어있는지 한번 씩 검토해보시기 바랍니다.\n\n"
} ,
  
  {
    "title"    : "for-loop는 이제 안녕",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin/2021/08/29/Why_not_for_loop.html",
    "date"     : "August 29, 2021",
    "excerpt"  : "for-loop 는 이제 그만 안녕\n\n\n\n제가 코드리뷰할 때 보통 왼쪽 코드를 오른쪽으로 고치는 것을 권장합니다. \n코틀린에서 제공하는 기본적인 API를 최대한 활용하는 것을 선호하고 반복문을 최대한 지양하는데,\n그 이유는 바로 코틀린이 함수형 프로그래밍 언어이기 때문입니다.\n\n함수형 프로그래밍 언어에서 For 반복문을 지양하는 이유\n\n일단 이유는 크게 3가지가 있습니다.\n\n\n  명령형 프로그래밍 vs 선언형 프로그래밍\n  불변형 객체를 ...",
  "content"  : "for-loop 는 이제 그만 안녕\n\n\n\n제가 코드리뷰할 때 보통 왼쪽 코드를 오른쪽으로 고치는 것을 권장합니다. \n코틀린에서 제공하는 기본적인 API를 최대한 활용하는 것을 선호하고 반복문을 최대한 지양하는데,\n그 이유는 바로 코틀린이 함수형 프로그래밍 언어이기 때문입니다.\n\n함수형 프로그래밍 언어에서 For 반복문을 지양하는 이유\n\n일단 이유는 크게 3가지가 있습니다.\n\n\n  명령형 프로그래밍 vs 선언형 프로그래밍\n  불변형 객체를 통한 원자성 유지\n  추상화를 통한 안정성 추구\n\n\n\n\n명령형 프로그래밍 vs 선언형 프로그래밍\n\n명령형은 어떻게 해야하는지에 초점이 맞춰진 프로그래밍이라면 \n선언형은 무엇을 해야하는지에 초점을 맞추는 프로그래밍 방식입니다.\n\n\n\n왼쪽의 반복문 예제는 반복문을 돌면서 어떻게 데이터를 넣을지를 설명하는 코드라면\n오른쪽 filter 예제는 어떤 데이터를 넣을지에 초점을 맞춘 코드라고 할 수 있습니다.\n\n찾아보면 다들 선언형 프로그래밍이 가독성이 좋다고하고 저도 동의하지만..\n사실익숙한 코드가 더 잘 읽히는 법이라 가독성 부분에서는 개인차가 존재한다고 생각합니다.\n\n불변형 객체를 통한 원자성 유지\n\n자바에서는 ArrayList를 이용해서 리스트를 관리하는 경우가 많았지만\nKotlin에서는 매번 새로운 불변형 List를 넘기는 식으로 관리하곤 합니다. \n만약 반복문 안에서 MutableList를 이용해서 조작하면 원자성이 깨질 수 있습니다.\n\n원자성이란?\n\n원자성이란 완전하고 견고한 상태이거나 아니면 아예 실패하는 실패 원자성(failure atomicity) 을 의미합니다.\n쉽게 말해 성공하면 깔끔하게 성공하거나, 실패하면 완전히 실패하는 성질로 \n실패했는데 상태가 변해있으면 원자성을 유지하지 못한 것이라 할 수 있습니다.\n깔끔하게 완전히 실패하면 다시 시도하거나 취소하여 실패의 영향이 전파되지 않도록 할 수 있습니다.\n\n예제를 봅시다.\n\n\n\n실패했는데 왼쪽의 경우는 newList가 변해있지만 오른쪽의 경우는 변해있지 않습니다. \n반복문을 사용하지 않고 불변형 객체를 넘기는 것으로 실패의 영향을 남기지 않을 수 있습니다.\n\n추상화를 통한 안정성 추구\n\n반복문에서는 종료 조건, 비교 조건, 반복 시점 등 한가지만 살짝 바뀌어도 깨지기 쉽습니다.\n반복문을 사용하는 대신 추상화된 함수를 검증 후 재사용하는 편이 좋습니다.\n결과적으로 언어에서 제공한 검증된 API를 사용하는 편이 훨씬 안정된다는 의미가 됩니다.\n만약 검증된 API가 없다면 새로운 연산자를 만들어 검증하고 해당 연산자를 재사용 하는 것이 좋습니다.\n\n\n\n리스트가 너무 커서 성능이 떨어진다면?\n\n반복문을 사용하는 이유 중에 리스트가 너무 커서 성능상의 이유로 \nfilter, map 등 리스트 연산자를 사용하지 않는 경우가 있습니다.\n\nfor (data in collection) {\n\t// 조건에 맞으면 데이터 변환\n\tif (data.isCondition) {\n\t    newList.add(NewData.from(data))\n\t}\n\n\t// N개의 아이템을 찾으면 종료\n\tif (newList.size &amp;gt;= N) {\n\t    break\n\t}\n}\n\n\n위의 반복문을 for-loop를 사용하지 않도록 바꾸면 아래와 같습니다.\n\nnewList.addAll(\n    collection.filter {\n        data.isCondition\n    }.map {\n        NewData.from(data)\n    }.take(N)\n)\n\n\n리스트의 크기가 크지 않다면 큰 문제가 되지 않겠지만 크기가 아주 크다면 얘기가 다릅니다.\n크기가 큰 리스트에서 filter, map 등을 이용하여 리스트 전체를 여러번 탐색하게 되면\n심각한 성능저하로 이어질 수 있습니다.\n\n이런 성능저하를 피하고자 반복문을 사용하게 되는 경우도 있겠지만 \n이러한 문제는 Sequence 를 이용해서 해결할 수 있습니다.\n\n\n\nSequence를 이용한 lazy한 연산\n\nnewList.addAll(\n    collection.asSequence().filter {\n        data.isCondition\n    }.map {\n        NewData.from(data)\n    }.take(N)\n    .toList()\n)\n\n\n.asSequence() 와 .toList()를 붙이는 것만으로도 쉽게 해결할 수 있습니다.\nSequence는 filter, map 등의 연산자가 모든 리스트를 모두 훑으며 진행되는 것이 아니라\n위의 반복문처럼 각 원소별로 filter, map 연산자가 lazy하게 동작하여\n리스트 전체를 돌지 않고 해결하므로 리스트의 크기가 아무리커도 성능저하가 일어나지 않습니다.\n\n\n\n자세한 내용은 코틀린 공식 문서를 참고하시고\n나중에 기회된다면 Sequence에 대해 자세히 다뤄보도록 하겠습니다.\n\n\n"
} ,
  
  {
    "title"    : "너, 나, 우리에게 Unit 테스트가 필요한 이유",
    "category" : "",
    "tags"     : " ",
    "url"      : "/tdd,/test/2021/08/07/Why_need_unit_test.html",
    "date"     : "August 7, 2021",
    "excerpt"  : "Unit Test 테스트란?\n\n\n\nUnit 테스트는 가장 작은 단위(기능 또는 함수)에 대한 검증을 의미합니다.\n일반적으로 Unit 테스트는 아래의 세가지 조건을 충족해야합니다. \n\n\n  실제 프로덕션 코드에는 포함되지 않는다.\n  네트워크와 같은 I/O나 UI등 외부 프레임워크에 의존하지 않는 순수한 로직만 검증한다.\n  매번 실행할 때 마다 같은 결과가 나와야 한다. (순수함수)\n\n\n실제 어플리케이션의 동작 전체를 검증하는 것은 통합테...",
  "content"  : "Unit Test 테스트란?\n\n\n\nUnit 테스트는 가장 작은 단위(기능 또는 함수)에 대한 검증을 의미합니다.\n일반적으로 Unit 테스트는 아래의 세가지 조건을 충족해야합니다. \n\n\n  실제 프로덕션 코드에는 포함되지 않는다.\n  네트워크와 같은 I/O나 UI등 외부 프레임워크에 의존하지 않는 순수한 로직만 검증한다.\n  매번 실행할 때 마다 같은 결과가 나와야 한다. (순수함수)\n\n\n실제 어플리케이션의 동작 전체를 검증하는 것은 통합테스트 또는 UI 테스트라고 하며,\n외부 프레임워크에 의존하지 않는 순수한 비즈니스 로직을 검증합니다. \n\n\n보통 테스트라면 많이 할수록 더 안정되고 꼼꼼해야할 것 같은 느낌이 듭니다.\n그래서 Unit 테스트를 많이하면 UI테스트의 부담도 줄고 프로그램이 더 안정될 것 같은 느낌을 받습니다.\n그러나 Unit 테스트와 통합테스트는 목적부터가 다릅니다.\n그렇다고 UI 테스트가 잇으니까 Unit 테스트가 필요없다는 것은 아닙니다. \n\n이번 포스팅에서는 Unit 테스트에 대한 오해와 필요성에 대해 소개합니다.\n\n\n\n\nUnit 테스트의 함정\n\n\n\nUnit 테스트가 프로그램의 품질을 결정하지 않는다.\n\nUnit 테스트가 있다하더라도 통합테스트, UI 테스트는 진행되어야 하고 통합테스트의 부담이 줄어들지는 않습니다. \n결국 Unit 테스트가 완성된 제품(프로그램)에 품질을 보장하지 않습니다. \n역설적으로 Unit 테스트는 코드의 안정성과 품질보다는 생산성에 더 긍정적인 영향을 줄 수도 있습니다.\n\n\n테스트 커버리지가 코드의 수준과 품질을 의미하지 않는다.\n\n테스트 코드를 처음 짜기 시작한 일부 개발자들이 이 테스트 커버리지에 집착하는 경향이 있습니다.\n그러나 이 테스트 커버리지가 소프트웨어의 수준과 품질에 비례하는 것은 아닙니다. \n개발자의 실력도 마찬가지로 테스트 커버리지를 높게 짜는 개발자가 실력이 더 좋은것도 아닙니다.\n\n물론 커버리지를 높이기 위한 노력이 도움이 될 수는 있겠으나\n이 커버리지에 집착하게되면 불필요한 테스트 코드를 짜거나 중복된 테스트를 하게 되는 등 오히려 독이될 수도 있습니다. \n\n너무 많은 테스트코드는 리팩토링을 방해한다\n\n테스트가 많을 수록 좋을 것 같지만 결과적으로 테스트코드 자체도 리팩토링의 영향을 받기 때문에 \n테스트코드가 많다는 것은 리팩토링 했을 떄 수정되어야 할 코드 역시 많다는 의미가 됩니다.\n결과적으로 과도하게 많은 테스트 코드는 오히려 리팩토링을 부담스럽게 만들 수 있습니다.\n\n그럼에도 필요한 이유?\n\n\n\n결국엔 위 함정들을 보면 자연스럽게 다음 질문이 떠오릅니다.\n\nUnit 테스트를 작성해도 어차피 테스트 해야할거면 짤 필요 없는거 아닌가?\n\n\n만약 필요가 없었다면 이렇게 장황하게 떡밥을 깔아가면서 포스팅을 작성할 이유가 없었겠죠?\n일단 필요한 이유는 크게 나를 위한 이유와 우리를 위한 이유 두가지로 나눠 설명할 수 있습니다.\n\n\n\n먼저 나를 위한 이유를 봅시다.\n\n\n코드의 안정성\n\n물론 이것이 프로그램의 품질과 직접 연결되지 않을 수는 있지만 검증을 일단 안하는 것 보다는 당연히 낫습니다. \n이것은 지금 내가 작성한 기능을 검증하는 것 뿐 아니라  \n나중에 수정된 코드로 인한 기존 기능의 영향도를 빨리 파악하고 검증할 수 있다는 장점이 있습니다.\n또한 검증 하는 과정에서 요구사항 도출과 버그를 미리 발견 할 수 있습니다.\n\n\n빠른 빌드로 검증과 테스트\n\nUnit 테스트 코드가 아니더라도 개발하는 과정에서 테스트용 코드를 작성하곤 합니다.\n그런데 어차피 로직을 테스트할 것이라면 단위테스트로 짜는 것이 빠릅니다. \n통합환경에서 프로젝트 전체를 빌드해서 UI로 테스트하는 것과 비교한다면 \n프레임워크로부터 독립적인 단위테스트만 빌드하여 검증하는 편이 훨씬 빠를 수 밖에 없습니다.\n제가 작업하던 환경 기준으로 본다면 안드로이드 앱을 빌드할 때 매 빌드마다 2~5분 정도 걸린다면 \n단위테스트는 모든 테스트가 아무리 길어도 1분이내에 모든 테스트를 검증할 수 있었습니다. \n이를 CI/CD 에 연동하여 개발/배포 프로세스에 녹여내는 것 또한 충분히 가능합니다. \n\n\n결과적으로 테스트코드를 안짜는 것보다 짜는 것이 개발속도가 더 빠르다고 할 수 있습니다.\n\n\n\n리팩토링에 유리\n\n리팩토링 할 때 기존에 작성되어 있는 로직들의 검증이 쉬워지기 때문에 리팩토링에 유리해집니다.\n테스트코드를 작성하는 것으로 리팩토링의 시작하기 때문에 테스트코드가 있는 로직이 리팩토링 하기도 부담이 적습니다. \n또한 단위테스트를 작성 하는 과정에서 기능별, 함수별로 나누게 되어 이미 리팩토링 하기 쉬운 구조가 됩니다.\n\n\n\n\n지금까지는 나를 위한 이유를 살펴보았다면 \n이번에는 내가 아닌 우리를 위한 이유를 소개합니다.\n\n코드의 의도 파악\n\n실제 코드를 보는 것 보다 테스트코드를 볼 때 코드의 의도를 파악하기가 훨씬 쉽습니다.\n코드를 보고 로직의 흐름과 예외 케이스를 짐작하는 것 보다 기대 결과값을 확인하는 편이 예상 동작 결과와 코드의 의도를 쉽고 빠르게 확인할 수 있습니다.\n\n그래서 PR 리뷰 시에 리뷰어가 코드 의도를 쉽게 파악하거나\n프로젝트에 새로 투입된 인원이 코드 파악할 때도 쉬워지고\n3개월 후의 내가 코드를 까먹어도 예상 결과를 확인할 수 있다. \n\n코드의 신뢰성\n\n\n  “이거 동작하는 코드 맞죠?”\n\n\n\n\n\n물론 코드를 검증하고 PR 리뷰를 요청하겠지만 \n리뷰어 입장에서는 어떤 케이스에 대해 어떻게 검증했는지 테스트코드가 없다면 확인할 수가 없습니다.\n따라서 테스트코드를 남겨서 어떤 케이스에 대해 어떻게 검증했는지를 남기면 리뷰를 받는 입장에서도 코드를 신뢰하고 리뷰할 수 있습니다.\n\n\n\nUnit Test Code를 작성하는 Tip\n\n\n\n테스트 짜기 쉬운 것 부터 시작해보기\n\n어렵게 생각하지 말고 유틸 함수나 비즈니스 로직부터 테스트코드를 작성해보기 시작해보는 것을 권장드립니다. \n\nIDE와 테스트 프레임워크를 최대한 활용\n\nIDE를 최대한 활용하면 메소드 추출이나 테스트코드 생성 등 테스트코드를 작성하는 부담과 비용을 줄일 수 있습니다.\n또한 XUnit 등의 테스트 프레임워크를 잘 활용하여 중복되는 테스트코드를 줄이는 등 테스트코드 자체를 잘 짜는 것도 중요합니다. \n\n테스트 가능한 로직과 불가능 한 로직 분리\n\nI/O나 UI등 외부 프레임워크에 의존하지 않도록 코드를 테스트 가능한 로직과 불가능한 로직을 분리해야 합니다.\n이러한 코드의 분리는 클린 아키텍처를 활용하여 도메인 로직을 분리할 수 있습니다. \n\n모든 함수와 기능을 테스트할 필요는 없다.\n\n존재하는 모든 예외케이스에 대해 테스트할 필요는 없습니다. \n오히려 필요한 정도로만, 혹은 본인이 안심되는 수준까지만 검증하는 것을 권장합니다. \n\n또한 private 함수는 테스트 할 필요가 없습니다. \n만약 필요하다면 그것은 private 함수이면 안된다는 반증일 수도 있습니다.\n오히려 너무 많은 테스트 코드를 작성하려하다 보면 중복된 테스트 코드등이 생기거나 결과적으로는 리팩토링에 부담이 될 수 있기 때문입니다.\n\n\n\n결론\n\n단위테스트가 있어도 결국 통합테스트가 필요하기 때문에 단위테스트의 필요성을 못느낄 수 있습니다.\n그러나 코드의 구조와 생상선과 신뢰성 측면만 보더라도 충분히 단위테스트를 짜는 데 의미가 있습니다.\n또한 리팩토링과 코드의 의도파악이란 측면에서 보면 지금 당장보다도 시간이 지날 수록\n더 중요해질 수 밖에 없습니다.\n혹시 Unit 테스트를 안짜보셨다면 지금부터라도 한번 짜보시면 어떨까요?\n"
} ,
  
  {
    "title"    : "Kotlin으로 실행 가능한 JAR 파일 만들기",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin/2021/07/31/Excutable-jar.html",
    "date"     : "July 31, 2021",
    "excerpt"  : "이번 포스팅에서는 코틀린으로 실행가능한 JAR파일을 만드는 방법을 소개하고자 합니다.\n\n\n\n\n개인적으로는 코틀린을 최대한 활용하고자, 업무용 스크립트도 코틀린으로 작성하는 편입니다. \n그러기위해서는 결국 코틀린으로 빌드한 실행파일이 필요합니다.\n일반적으로 코틀린으로 JVM 기반의 어플리케이션을 만들기 때문에\n실행가능한 JAR 파일을 만드는 방법을 공유하고자 합니다. \n\n\n첫번째로 프로젝트를 생성해봅니다.\n저는 안드로이드 개발자다보니 gra...",
  "content"  : "이번 포스팅에서는 코틀린으로 실행가능한 JAR파일을 만드는 방법을 소개하고자 합니다.\n\n\n\n\n개인적으로는 코틀린을 최대한 활용하고자, 업무용 스크립트도 코틀린으로 작성하는 편입니다. \n그러기위해서는 결국 코틀린으로 빌드한 실행파일이 필요합니다.\n일반적으로 코틀린으로 JVM 기반의 어플리케이션을 만들기 때문에\n실행가능한 JAR 파일을 만드는 방법을 공유하고자 합니다. \n\n\n첫번째로 프로젝트를 생성해봅니다.\n저는 안드로이드 개발자다보니 gradle이 익숙하여 gradle Kotlin/JVM 으로 프로젝트를 생성합니다. \n\n\n\n\n\n\n프로젝트가 생성되었다면 아래와 같이 간단히 hello world 프로그램을 작성해봅니다.\n\n\n\n\nIDE에서 직접 실행하면 다음과 같이 잘 실행되는 것을 확인할 수 있습니다.\n\n\n\n\n\n그럼 이제 이 프로그램을 다른 곳에서도 실행할 수 있도록 jar 파일로 생성해봅시다.\njar 파일로 만드는 것은 우측 gradle 탭의 태스크에서도 실행 가능합니다.\n\n\n\n참고로 jar 파일은 터미널에서 아래와 같이 입력하여 실행할 수 있습니다.\n\n$ java -jar {jar 파일 이름}\n\n\n\n문제는…\njar 파일을 생성하고 실행하면 다음과 같이 나오고 제대로 실행되지 않습니다.😱😱😱\n\n\n  no main manifest attribute, in ExecutableJarExample-1.0-SNAPSHOT.jar\n\n\n\n\n이 문제는 메인클래스를 찾지 못해서 발생하는 문제로\n아래와 같이 build.gradle파일에 manifest 설정을 jar 태스크에 추가해주면 됩니다. \n\njar {\n    manifest {\n        attributes &#39;Main-Class&#39;: &#39;dev.haenara.sample.MainKt&#39; // 메인 함수가 담긴 클래스 패키지명\n    }\n    archiveName &#39;HelloWrold.jar&#39; // jar 파일 이름\n}\n\n\n\n이와 별개로 제가 예전에 삽질했던 문제가 있어서 첨언하자면\n혹시 gradle 버전이 낮거나 설정이 안맞으면 아래와 같이 에러가 발생할 수 있습니다.\n저는 예전에 이 부분 때문에 오랫동안 삽질했던 기억이 나네요..😢\n\n\n  Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics\n\n\n\n이 경우에는 jar 빌드 스크립트에 아래 내용을 추가합니다. \n\njar {\n    ...중략...\n    from { configurations.default.collect { it.isDirectory()? it : zipTree(it) } }\n}\n\n\n\n\n이것을 이용하여 안드로이드 프로젝트에 java/kotlin library 을 생성하면 안드로이드 스튜디오에서도 데스크탑용 앱 또는 jar 스크립트를 만들 수 있습니다.\n\n\n\n\n  gralde 세팅은 동일하게 구성하면 됩니다.\n\n\n이것을 이용한 안드로이드/PC 크로스플랫폼 개발도 가능한데, 이 것은 차후에 기회가 된다면 풀어보도록 하겠습니다.\n\n\n"
} ,
  
  {
    "title"    : "이젠 안녕, 글또!",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2021/05/02/Reviewing_guelddo.html",
    "date"     : "May 2, 2021",
    "excerpt"  : "글또 5기 활동으로서 마지막 글\n\n글또 활동으로서 2주에 한번 씩 블로그에 글을 써왔는데 이번이 마지막 글이 되었다. \n6개월이란 기간이 꽤 길 것이라 예상했지만 지나고보니 정말 순식간에 지나가버렸다. \n마지막답게 간단한 회고로 정리해보고자 한다.\n\n\n나는 왜 글또를 시작 했는가?\n\n글또 모임 자체는 어렴풋이 알고 있었으나 글또 4기로 활동한 직장 동료로 부터 추천을 받았다.\n\n정개발님의 좋은 개발자는 좋은 작가다.라는 말에 감명받아 본격...",
  "content"  : "글또 5기 활동으로서 마지막 글\n\n글또 활동으로서 2주에 한번 씩 블로그에 글을 써왔는데 이번이 마지막 글이 되었다. \n6개월이란 기간이 꽤 길 것이라 예상했지만 지나고보니 정말 순식간에 지나가버렸다. \n마지막답게 간단한 회고로 정리해보고자 한다.\n\n\n나는 왜 글또를 시작 했는가?\n\n글또 모임 자체는 어렴풋이 알고 있었으나 글또 4기로 활동한 직장 동료로 부터 추천을 받았다.\n\n정개발님의 좋은 개발자는 좋은 작가다.라는 말에 감명받아 본격적으로 글을 써보기 위해 글또에 지원하였는데 \n나는 아무래도 둘다 아직 멀었나보다…\n\n마침 개인 블로그를 시작하는 시기와 맞물려 블로그를 새로 파고 글또 활동 겸 글을 쓰게 되었다.\n블로그 활동을 통해 개인의 브랜딩도 생각을 했는데 그 부분에서는 많은 아쉬움이 남는다.\n\n글또를 통해 무엇을 얻었는가?\n\n역설 적이게도 글을 쓰면 쓸 수록 내 작문 실력의 부족함과 글쓰기의 중요성을 깨닫게 되었다.\n\n이 글들이 모여서 좋은 레퍼런스가 될 수도 있겠지만 \n그 보다도 내 스스로 새로운 글감을 찾기 위해 새로운 것을 공부하게 된다는 점에서 굉장히 많은 도움이 되었다. \n아마 글또가 아니었다면 내가 이렇게 까지 새로운 것을 계속 공부하지 않았을 것 같고 하더라도 훨씬 더 깊이가 얕았을 것이다.\n\n다른 글또 회원들로 부터의 피드백 또한 여러가지로 자기객관화에 도움이 많이 되긴 했지만 \n이전과는 달리 다른 사람들이 읽는다는 전제로 글을 쓴 덕분인지 글 자체에도 좀 더 신경을 많이 쓰게되고 내용도 좀 더 깊이있게 다루게 된 것 같다.\n\n앞으로도 꾸준히 글을 써야겠다는 생각은 들지만 과연 글또 없이 얼마나 꾸준히 쓸 수 있을까? 하는 걱정이 된다.\n\n아쉬운 점을 꼽자면 이번 기수는 코로나로 인해 얼굴한번 제대로 보지 못했다는 점이 아무래도 가장 큰 아쉬움으로 남는다. \n\n또한 중후반으로 갈 수록 여러가지 가정사와 더불어 바쁜 프로젝트 일정으로 주말내내 사무실 출근을 하는 등 도저히 글을 쓸 수 없는 여러가지 경우들이 생겼다. \n틈틈히 글을 쓰는 대신 미루고 미뤄 주말에 몰아서 쓰려던 습관들 때문에 생각만큼 글을 많이 쓰지 못한 아쉬움이 많이 남는다.\n\n\n마치면서\n\n사람은 언제나 바쁘다. \n물론 더 바쁜날도 있고 덜 바쁜날도 있겠지만 살아보니 결국엔 그 당시에 나는 바쁘더라.\n중요한 것은 얼만큼 객관적으로 바쁘냐가 아니라 우선순위 조정을 통한 틈틈히 시간내서 무엇가를 하는 것이 중요한 것 같다.\n결국 선택과 집중인데 이번 글또 활동을 선택한 비율이 조금 낮았던 것 같다.\n\n혹시라도 글또 활동을 고민하고 계신 분이 이 글을 읽고 있다면 꼭 한번 해보기를 권해드린다. \n기술적인 성장이나 브랜딩도 있겠지만 스스로를 다시 돌아보는 좋은 계기가 될 것이라고 자신있게 말씀드린다.\n\n\n"
} ,
  
  {
    "title"    : "AndroidStudio에서 Firebase 앱 내부배포를 한방에 해결하기",
    "category" : "",
    "tags"     : " ",
    "url"      : "/android,firebase/2021/03/27/Firebase_App_Distribution_on_AndroidStudio.html",
    "date"     : "March 27, 2021",
    "excerpt"  : "Firebase 앱 내부배포?\n\n\n\nFirebase에서는 개발자를 위한 정말 다양한 서비스를 제공하고 있는데 오늘 소개할 서비스는 Firebase 앱 배포 입니다.  \nFirebase 앱 배포를 통해서 스토어에 올리지 않고 팀원들에게만 공유하여 다운받을 수 있도록 배포할 수 있습니다. \n새로운 버전을 출시할 때 마다 테스터느 손쉽게 다운 받아서 테스트 해볼 수 있으며  \n버전별로 테스트할 수 있도록 이전 버전의 다운로드도 지원합니다. \n\n...",
  "content"  : "Firebase 앱 내부배포?\n\n\n\nFirebase에서는 개발자를 위한 정말 다양한 서비스를 제공하고 있는데 오늘 소개할 서비스는 Firebase 앱 배포 입니다.  \nFirebase 앱 배포를 통해서 스토어에 올리지 않고 팀원들에게만 공유하여 다운받을 수 있도록 배포할 수 있습니다. \n새로운 버전을 출시할 때 마다 테스터느 손쉽게 다운 받아서 테스트 해볼 수 있으며  \n버전별로 테스트할 수 있도록 이전 버전의 다운로드도 지원합니다. \n\n\n자세한 소개는 공식문서를 참고해보세요.\n\n내부배포를 Android Studio 에서?\n\n보통은 Firebase Console을 웹으로 접속하여 APK파일을 직접 업로드하여 배포하지만 \nAndroid Studio에서도 Firebase에서 app-distribute 플러그인을 제공하여 아주 손쉽게 배포할 수 있습니다.\n사실 CLI, Fastlane 등을 통해서도 배포할 수 있지만 \n이번 포스팅에서는 Gradle 플러그인을 이용한 방법을 소개합니다.\n\n\n자세한 내용은 공식문서를 참조하세요.\n\n\n의존성 추가 및 플러그인 적용\n\n우선 플러그인 사용을 위해 build.gradle(root)에 다음과 같이 추가합니다. \n\nbuildscript {\n    repositories {\n        google()\n    }\n    dependencies {\n        classpath &#39;com.google.firebase:firebase-appdistribution-gradle:2.1.0&#39;\n    }\n}\n\n\nbuild.gradle(app)에는 다음과 같이 플러그인을 적용합니다. \n\nplugins {\n    id &#39;com.google.firebase.appdistribution&#39;\n}\n\n\n\n\n빌드 타입에 Firebase 배포 설정\n\n플러그인 적용이 완료되었다면 이제 출시노트와 대상 테스터를 설정합니다.\nbuildTypes 또는 ProductFlavor에 firebaseAppDistribution 설정을 추가합니다.\n\n출시노트와 테스터는 String 객체로 직접 입력할 수도 있고 파일을 참조하도록 할 수도 있습니다.\n테스터의 경우는 “,” 단위로 여러명을 지정할 수도 있고 아예 그룹이름 단위로 선택할 수도 있습니다.\n아래 예시에서는 debug 빌드일 때 프로젝트 내의 RELEASE_NOTE.txt파일을 참조하도록 하였습니다.\n\nandroid {\n    ...\n    buildTypes {\n        ...\n        debug {\n            ...\n            firebaseAppDistribution {\n                releaseNotesFile = &quot;${rootDir}/RELEASE_NOTE.txt&quot;\n                testers = &quot;qatester@test.moc&quot;\n            }\n        }\n    }\n}\n\n\n좀 더 자세한 설정 및 활용방법은 공식문서를 참조하세요.\n\n\n\n배포 해보기\n\n\n\n실제로 배포를 해봐야 동작하는 지 알 수 있겠죠?\n우선 배포를 하기 전에 인증 부터 해야하는데요 인증 방법은 세가지가 있습니다.\n\n\n  플러그인의 로그인 작업을 통해 Google 계정에 로그인\n  Firebase 서비스 계정 사용자 인증 정보 사용\n  Firebase CLI를 사용하여 로그인\n\n\n인증하는 방법이 몇가지 있겠지만 커맨라인이 익숙하신 분들이라면 CLI를 추천드립니다.\n나머지 인증 방법이 궁금하시다면 공식문서를 참조하세요.\n\nCLI로 인증하기\n\nCLI 인증을 위해선 Firebase CLI 를 다운로드 받아야 합니다.\n콘솔창에 아래와 같이 입력하면 쉽게 다운 받을 수 있습니다.\n\n$ curl -sL https://firebase.tools | bash\n\n\n설치가 완료되었다면 다음 명령어를 입력하고 브라우저에서 인증 합니다.\n\n$ firebase login\n\n\n브라우저에서 인증을 완료하면 다음과 같은 화면을 확인할 수 있습니다.\n\n\n\n\n\n이젠 정말 배포 해보기\n\n플러그인이 정상적으로 설정되었다면 gradle task 목록에 다음과 같이 태스크가 추가 되어 있는 것을 확인할 수 있습니다.\n\n\n\n해당 태스크를 실행하여 실제로 파이어베이스 콘솔에 앱이 잘 배포되는지 확인합니다.\n\n\n\n🤔 그런데 결국 출시노트는 일일히 적어야 하는거 아냐?\n\n저는 이쯤에서 이런 고민을 했습니다.\n\n😠 결국 출시노트는 여전히 손으로 다 적어야 하네\n😣 버전도 매번 일일히 올려야 하는 거잖아\n😩 그냥 웹에서 하던걸 안드로이드 스튜디오로 가져온게 다라면 그게 무슨 의미가 있을까?\n\n플러그인을 적용하면 분명 콘솔에 접속 할 필요도, APK를 직접 업로드 할 필요도 없어서 간편한 것은 사실이지만\n아쉬운 점은 출시노트를 매번 일일히 수동으로 적고 버전도 매번 하나씩 올려주어야 한다는 것입니다.\n\n하지만 기왕 자동화를 시작할꺼면 끝까지 해야겠지요? 🤩\n결과적으로 저는 버전관리와 출시노트를 자동으로 생성하는 것 까지 한세트로 묶어 자동화를 시도합니다.\n\n\n버전 관리 배포하기\n\n\n\n\nGit 명령어를 이용해서 출시노트를 자동으로 생성하고 버전 역시 자동으로 하나씩 올리는 방법을 소개합니다.\n버전을 별도의 파일로 관리하기\n\n우선 버전을 version.properties라는 별도 파일로 생성하여 관리해봅시다.\n별도의 파일로 관리하는 이유는 gradle에서 손쉽게 버전을 읽고 덮어씌워 저장하기 위해서입니다.\n일단 프로젝트에 version.properties파일을 다음과 같이 생성해주세요.\n\nversion_name=1.0.0\nversion_code=1\n\n\n이후 해당 프로퍼티 파일을 읽어서 버전네임과 코드를 사용하도록 build.gradle(app)에 다음과 같이 코드를 추가합니다.\n\ndef versionProp = {\n    def versionProp = new Properties()\n    versionProp.load(new FileInputStream(&quot;$project.rootDir/version.properties&quot;))\n    versionProp.each { prop -&amp;gt;\n        project.ext.set(prop.key, prop.value)\n    }\n    return versionProp\n}\n\ndef verCode = {\n    def prop = versionProp()\n    return Integer.valueOf(&quot;${prop[&#39;version_code&#39;]}&quot;)\n}\n\ndef verName = {\n    def prop = versionProp()\n    return &quot;${prop[&#39;version_name&#39;]}&quot;\n}\n\nandroid {\n    ...\n\n    defaultConfig {\n        versionCode verCode()\n        versionName verName()\n        ...\n    }\n}\n\n\nversion.properties의 버전을 하나씩 올리고 새로 저장하는 함수는 아래와 같습니다.\n해당 함수도 build.gradle(app)에 추가해주세요.\n\ndef updateVersionProperties(name, code) {\n    def versionProp = new File(&quot;${rootDir}&quot;, &#39;version.properties&#39;)\n    def newVersion = name.substring(0, name.lastIndexOf(&#39;.&#39;)) +\n            &quot;.${Integer.valueOf(name.split(&#39;\\\\.&#39;).last()) + 1}&quot;\n    versionProp.text = &quot;version_name=${newVersion}\\n&quot; +\n            &quot;version_code=${code + 1}&quot;\n}\n\n\n\n\nGit Log로 출시노트 만들기\n\n이제 출시노트를 자동생성해볼 차례입니다.\nGit Log를 이용하여 그간 작업한 내용을 출시노트로 변환하는 작업을 할 겁니다.\n\n일단 마지막 태그부터 최신까지의 커밋 메세지를 출력하는 git 명령어는 다음과 같습니다.\n\ngit log $(git describe --tags --abbrev=0)..HEAD --oneline --format=&quot;%s&quot;\n\n\n이제 이 명령어를 gradle에서 실행하면 되는데…\n문제는 $(git describe --tags --abbrev=0)와 같이 명령어 안의 명령어를 한번에 실행할 수가 없다는 점입니다.\n\n따라서 \n\n1. 마지막 태그 버전 가져오기\n\n2. 특정 버전부터 최신까지의 로그 출력하기\n\n이렇게 두가지 커맨드를 각각 함수로 호출해주고 출력한 내용을 RELEASE_NOTE.txt 파일로 저장해야 합니다.\n아래의 함수가 두가지 동작을 처리하는 함수인데 이 역시 build.gradle(app)에 추가합니다.\n\ndef createReleaseNote() {\n    def lastTag = {\n        def stdout = new ByteArrayOutputStream()\n        exec {\n            commandLine &#39;git&#39;, &#39;describe&#39;, &#39;--tags&#39;, &#39;--abbrev=0&#39;\n            standardOutput = stdout\n        }\n        return stdout.toString().trim()\n    }\n\n    def stdout = new ByteArrayOutputStream()\n    exec {\n        commandLine &#39;git&#39;, &#39;log&#39;, &quot;${lastTag()}..HEAD&quot;, &#39;--oneline&#39;, &#39;--format=%s&#39;\n        standardOutput = stdout\n    }\n    def text = stdout.toString().trim()\n    new File(&quot;${rootDir}&quot;, &quot;RELEASE_NOTE.txt&quot;).text = text\n    return text\n}\n\n\n참고로 --format=%s 는 커밋 메세지만 출력하도록 하는 포맷인데 \n%h를 추가하면 커밋 리비전도 함께 출력할 수 있고 필요에 따라 포맷을 원하는대로 수정해서 쓸 수 있습니다.\n\n\n\n  RELEASE_NOTE.txt 파일은 .gitignore 파일에 추가해서 커밋에 추가되지 않도록 하는 것을 권장합니다.\n\n\n\n\n버전별 Git Tag 남기기\n\n이제 버전 네임과 코드가 올라간 것을 다른 팀원들과도 Commit으로 공유하고 출시를 tag 로 남겨봅시다.\n아래 함수도 역시 build.gradle(app)에 추가합니다.\n\ndef gitCommitAndTagVersion(releaseNote, verName) {\n    try {\n        exec { commandLine &#39;git&#39;, &#39;reset&#39;, &#39;HEAD&#39; }\n        exec { commandLine &#39;git&#39;, &#39;add&#39;, &quot;${rootDir}/version.properties&quot; }\n        exec { commandLine &#39;git&#39;, &#39;commit&#39;, &#39;-m&#39;, &quot;v${verName} is released\\n\\n${releaseNote}&quot; }\n        exec { commandLine &#39;git&#39;, &#39;tag&#39;, &quot;v${verName}&quot; }\n    }\n    catch (Exception e) {\n        e.printStackTrace()\n    }\n}\n\n\n\n\n\n  혹시 해당 기능이 동작 하지 않는다면 터미널이나 커맨드 콘솔에서 git 동작하는지 우선 확인해야 합니다. \n윈도우의 환경변수나 맥/리눅스의 PATH에 git 경로를 추가해주시면 해결할 수 있습니다.\n\n\n\n\n빌드 및 배포 하기\n\ntask를 생성하고 dependsOn 으로 의존관계를 만들어 둡니다.\n\ntask _1_updateVersion(group: &#39;_sample_&#39;) {\n    doLast {\n        // check if anything has changed\n        def releaseNote = createReleaseNote()\n        if (releaseNote.isBlank())\n            throw new GradleException(&#39;Nothing has changed from last tag.&#39;)\n\n        updateVersionProperties(verName(), verCode())\n        gitCommitAndTagVersion(releaseNote, verName())\n    }\n}\n\ntask _2_buildAndDistribute(dependsOn: &#39;clean&#39;, group: &#39;_sample_&#39;) {}\n_2_buildAndDistribute.dependsOn(&#39;assemble&#39;)\n_2_buildAndDistribute.dependsOn(&#39;appDistributionUploadDebug&#39;)\n\n\ntask에서 group으로 task의 그룹을 지정할 수 있습니다.\ndependsOn으로 해당 태스크가 실행되기 전에 어떤 task가 실행될 것인지 지정할 수 있습니다.\n위 예제에서 dependsOn의 순서는 되도록 지켜주세요.\n\n\n\n🚀 이제 남은 것은 실전 뿐\n\n\n\ntask 1, 2를 순서대로 실행합니다.\n\n\n  만약 RELASE_NOTE를 수정해서 배포하고 싶다면 \ntask1 실행 이후 수동으로 RELASE_NOTE를 수정하신 다음 task2 실행하시면 됩니다.\n\n\n\n그리고 배포된 앱을 확인합니다.\n\n\n\n어때요? 참 쉽죠??\n\n\n\n샘플\n\n각 부분별로 설명하다보니 조금 복잡해보이고 이해가 어려울 수 있을 것 같습니다.\n아래 샘플 프로젝트를 참고해서 어떤식으로 구성 되어 있는지 확인해보시면 좋을 것 같습니다.\n아마 README와 build.gradle(app) 파일만 훑어보셔도 충분히 참고가 될 것 같습니다 😄\n\n\n\n\nhttps://github.com/HaenaraShin/Firebase-App-Distribution-Plugin-Sample\n\n도움이 되셨다면 샘플 프로젝트에 스타도 한번씩 부탁드립니다 ⭐️\n\n\n"
} ,
  
  {
    "title"    : "Ktor는 Retrofit을 대신할 수 있을까?",
    "category" : "",
    "tags"     : " ",
    "url"      : "/android,/kotlin,/ktor/2021/03/21/Ktor_tutorial.html",
    "date"     : "March 21, 2021",
    "excerpt"  : "Ktor가 뭔데?\n\n\n\n  공식 페이지 https://ktor.io/\n\n\n\n\nKtor는 Kotlin을 만든 Jetbrains사에서 만든 오픈소스 코틀린 통신 프레임워크 입니다. \n아무래도 코틀린을 만든 회사가 만들었기 때문에 공식 라이브러리로서의 기대감을 받고 있습니다. \n이 글에서는 서버보다는 주로 클라이언트 관점에서 Ktor에 대해 분석해봅니다.\n\n\n💁‍♂️ 참고로 Kay-tor 라고 발음합니다. 대략 케이토어 정도로 발음하면 되겠네요...",
  "content"  : "Ktor가 뭔데?\n\n\n\n  공식 페이지 https://ktor.io/\n\n\n\n\nKtor는 Kotlin을 만든 Jetbrains사에서 만든 오픈소스 코틀린 통신 프레임워크 입니다. \n아무래도 코틀린을 만든 회사가 만들었기 때문에 공식 라이브러리로서의 기대감을 받고 있습니다. \n이 글에서는 서버보다는 주로 클라이언트 관점에서 Ktor에 대해 분석해봅니다.\n\n\n💁‍♂️ 참고로 Kay-tor 라고 발음합니다. 대략 케이토어 정도로 발음하면 되겠네요. (출처)\n\n\n\nKtor의 특징\n\n1. 서버와 클라이언트를 한방에\n\n가장 큰 특징은 서버와 클라이언트 모두 지원한다는 점입니다. \n그래서 사실 클라이언트 보다는 서버 구축에 초점이 맞춰져있는 느낌도 있긴 하지만\n하나의 프로젝트에서 하나의 프레임워크로 서버/클라이언트를 모두 개발할 수 있습니다.\n\n\n2. 멀티플랫폼 지원\n\n순수한 코틀린으로만 구현되어 있다보니 코틀린 멀티플랫폼을 지원합니다. \n즉 웹서버, 안드로이드, iOS까지 하나의 프레임워크로 해결할 수 있다는 의미입니다.\n결과적으로 위의 서버/클라이언트를 모두 지원하는 장점과 이어지는 것 같아요. \n기존에 자바진영에서 많이 사용하던 다른 통신모듈과 가장 큰 차별점이 이부분이라고 생각합니다.\n\n\n3. 공식 라이브러리\n\n코틀린 공식 페이지에서도 소개가 되고 있듯이, 공식적으로 미는 프레임워크입니다.\n바꿔말하면 지금은 조금 부족하더라도 앞으로도 꾸준히 지원될 것을 기대해볼 수 있습니다.\n또한 IntelliJ 플러그인 등을 통해 좀 더 손쉽게 개발할 수 있도록 여러가지 지원을 하고 있습니다.\n\n\n샘플 프로젝트\n\n\n\n\n  샘플 프로젝트 링크 : https://github.com/HaenaraShin/Ktor-sample\n\n\n\n일단은 한번 써봐야 이게 좋은지 않좋은지 알 수 있겠죠?\n서버 구성 코드도 함께 있다면 좋겠지만.. 이 글에서는 Android 기준으로 작성합니다.\n예제 코드에서는 core 모듈을 분리하여 작성하였기 때문에 \n안드로이드를 모르시더라도 순수 Kotlin(JVM)으로 구현하는 코드를 참고하실 수 있습니다.\n\n\n\n  샘플 작성하면서 Kotlin, Ktor 버전에 따라서 동작차이가 컸습니다.\n혹시 따라해보시다가 동작이 이상하다면 반드시 버전을 꼭 확인해주세요.\n\n\n\n해당 샘플은 아래 버전 기준으로 작성되었습니다.\n\n  AndroidStudio 4.1.3\n  Kotlin 버전 1.4.30\n  Ktor 버전 1.5.2\n\n\n샘플에서 사용하는 API는 🐈 랜덤한 고양이 이미지 URL을 제공하는 TheCatApi입니다.\nAPI의 자세한 사양은 API 공식 문서를 확인해주세요.\n\n\n\n의존성 추가\n\nroot 수준의 build.gralde 에 다음과 같이 의존성을 추가해주세요.\n\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath &#39;org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.30&#39;\n        classpath &#39;org.jetbrains.kotlin:kotlin-serialization:1.4.30&#39;\n    }\n}\n\n\napp 수준의 build.gralde 에 다음과 같이 플러그인과 의존성을 모두 추가해주세요.\n\nplugins {\n    ...\n    id &#39;org.jetbrains.kotlin.plugin.serialization&#39;\n}\n\ndependencies {\n    ...\n    implementation &#39;io.ktor:ktor-client-core:1.5.2&#39;\n    implementation &#39;io.ktor:ktor-client-android:1.5.2&#39;\n    implementation &#39;io.ktor:ktor-client-serialization:1.5.2&#39;\n    implementation &#39;io.ktor:ktor-client-serialization-jvm:1.5.2&#39;\n    implementation &#39;org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0&#39;\n}\n\n\n데이터 모델객체 추가\n\nCat 데이터 응답은 다음과 같은 형태로 옵니다. (불필요한 내용은 생략했습니다.)\n\n[\n   {\n      &quot;id&quot;:&quot;36e&quot;,\n      &quot;url&quot;:&quot;https://cdn2.thecatapi.com/images/36e.jpg&quot;,\n      &quot;width&quot;:1280,\n      &quot;height&quot;:853\n   }\n]\n\n\n이것을 Kotlin Data 클래스로 바꾸면 아래와 같이 됩니다.\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class Cat(\n    val height: Int,\n    val id: String,\n    val url: String,\n    val width: Int\n)\n\n\n해당 예제에서는 직렬화를 사용하기 위해 @Serializable 어노테이션을 사용했습니다.\n\n⚠️ 혹시 에러가 나진 않나요?\n\nSerializable 어노테이션이 제대로 인식되지 않거나 에러로 인식되어 빨간 밑줄이 뜨는 경우가 있습니다.\n그러나 이 경우에도 사실 빌드를 해보면 잘 됩니다. 😱\nAndroidStudio 4.2.0 이상을 사용하면 정상적으로 해결됩니다만\n이런 것이 신경쓰이는 분이 아니시라면 4.2.0은 아직 베타버전이므로 굳이 설치하기를 권장드리지는 않습니다. \n\nAPI 호출하기\n\n제일 먼저 HttpClient를 생성해봅니다.\n\nval client = HttpClient() \n\n\n\n\n통신 엔진\n\n여기서 중요한 특징은 HttpClient 안에 생성자안에 통신 엔진을 명시할 수 있습니다.\n\n만약 적지 않으면 기본 엔진으로 동작하며, 플랫폼에 따라 다른 엔진을 적용하는 것도 가능합니다.\nOkHttp 엔진을 사용하여 기존에 사용하던 Interceptor 등을 연동하는 등\n호환성을 위해 여러가지를 고려한 것이 눈에 띕니다.\n\n엔진에 대해 좀 더 자세히 알고 싶다면 공식문서를 참고해보세요.\n\n기능(Feature) 설정하기\n\n단순히 통신만 하는 것이 아니라 인증, Json직렬화 등 다양한 기능을 지원합니다.\n이러한 기능을 적용하려면 HttpClient에 Feature를 설치해야 합니다.\n예제에서는 Json직렬화를 사용해보았습니다.\n\n\n기능에 대해서 좀 더 자세히 알고 싶다면 공식문서를 참고해보세요.\n\nval client = HttpClient() {\n    install(JsonFeature) {\n        serializer = KotlinxSerializer(\n            Json {\n                prettyPrint = true\n                ignoreUnknownKeys = true\n                isLenient = true\n                encodeDefaults = false\n            }\n        )\n    }\n}\n\n\n\n\n진짜로 API 호출해보기\n\nHttpClient를 생성하고 get() 함수로 호출해봅시다.\n지금 API는 HTTP GET메소드라서 get()이고 \n만약 POST로 호출해야 한다면 post()를 쓰시면 됩니다. \n\nclient.get&amp;lt;List&amp;lt;Cat&amp;gt;&amp;gt;(&quot;https://api.thecatapi.com/v1/images/search&quot;)\n\n\n해당 예제에서는 직렬화를 사용했기 때문에 바로 Cat 모델로 받을 수 있습니다.\n\n⚠️ 혹시 에러가 나진 않나요?\n\nget() 함수는 코루틴의 suspended 함수이므로 상위 함수도 suspended 지정자를 붙여주어야 합니다.\n\n\n안드로이드에 적용해보기\n\n아까 생성한 API 호출코드와 받아온 이미지를 Glide로 보여줍니다.\n\nsuspend fun findCat() {\n    val cats = MyClass().getCatFromApi()\n    showUrl(cats.first())\n}\n\nfun showUrl(cat: Cat) {\n    CoroutineScope(Main).launch {\n        Glide.with(this@MainActivity)\n            .load(cat.url)\n            .into(imageView)\n    }\n}\n\n\n마지막으로 버튼을 누르면 코루틴 함수를 호출할 수 있도록 합니다.\nbutton.setOnClickListener {\n    CoroutineScope(IO).launch {\n        findCat()\n    }\n}\n\n\n\n\n예제 실행 결과\n\n\n\n어떤가요? 😊\n\n\n\n써보니까 어때? Retrofit 보다 좋아?\n\n\n\n  Ktor 써보니까 좋아? Ktor가 Retrofit보다 좋아??\n\n\n🤔 솔직히 더 좋다고 말씀드리기는 어려운 것 같아요.\n멀티플랫폼을 고려하는 것이 아니라면 안드로이드에선 아직 Retrofit이 나을 것 같습니다.\n그렇게 생각하는 이유는 다음과 같습니다.\n\n1. 참고할 자료가 너무 적다\n\n공식문서가 잘 되어있긴 한데.. 공식문서 외에는 예제나 자료를 찾는게 너무 어려웠습니다.\n공식문서에 나와있지 않은 내용은 찾기가 힘들었고 StackOverflow 조차도 참고할 것이 많지 않았습니다.\n특히나 자료가 클라이언트 사이드보단 서버사이드가 압도적으로 많았고\n예외가 많을 수 밖에 없는 통신 모듈에서 참고할 사례와 자료가 적다는 것은 프로덕션에 적용하기에 큰 리스크라고 생각됩니다.\n\n2. 코루틴을 써야 한다.\n\n사실 당연한 점이라서 이건 단점이라고 하기도 좀 그렇습니다만\n개인적으로는 RxJava로 적용된 프로젝트를 마이그레이션 하는 것을 고려했었기 때문에 아쉬운 점으로 꼽았습니다.\n코루틴이 적용된 것은 분명 장점이긴 하지만 RxJava와 같은 다른 프레임워크를 사용할 수 없다는 한계가 있었습니다.\n물론 멀티플랫폼이기 때문에 어쩔 수 없는 점은 이해하지만 한편으로는 아쉬운 점이었습니다.\nRetrofit이 Callback, RxJava, 코루틴 모두 적용할 수 있다는 점에서 상대적으로 아쉬운 점입니다.\n\n3. 코틀린 버전에 민감함\n\n샘플작성하면서 사실 버전때문에 굉장히 많은 삽질을 했습니다.\n결과적으로는 Kotlin, Ktor, Android Studio 셋의 버전을 모두 최신으로 올려서 해결했지만\n중간에 어노테이션이 에러로 뜨지만 빌드는 된다던가 하는 경우 등 난해한 문제들을 겪었습니다.\n\n\n\n요약하자면…\n\n위 단점을 모두 모아 한줄로 써보자면 ‘아직은 아쉽다’ 정도가 되겠네요.\n세가지 단점 모두 시간이 지나면 해결될 문제들로 생각됩니다. \n\n즉 쓸만해보이고 앞으로 더욱 쓸만해보이지만\n아직까지는 (특히나 클라이언트 사이드에서는) 좀 성숙도가 떨어지지 않나?🤔 하는 생각이 듭니다.\n공식적으로 미는 프레임워크인 만큼 앞으로의 기대가 크지만\n당장 상용 프로젝트에 적용하기에는 조금 이른 감이 있다고 생각합니다.\n"
} ,
  
  {
    "title"    : "[라뗴칼럼] 백부장님의 2가지 가르침",
    "category" : "",
    "tags"     : " ",
    "url"      : "/latte/2021/02/21/Latte_back.html",
    "date"     : "February 21, 2021",
    "excerpt"  : "\n  백부장님의 2가지 가르침을 공유합니다.\n\n\n백부장님은…\n\n\n\n전 회사에서 서버개발자로 함께 일한 분이셨다.\n나와는 두바퀴 띠동갑이셨는데 ‘그냥 형처럼 생각해’라고 말씀하시며 잘 챙겨주셨다.\n금융과 SI쪽에서 굵직한 경력들이 있는 정말로 무협지에 나오는 재야의 고수와 같은 분이셨다.\n코딩도 코딩이지만 짬에서 나오는 도메인 이해와 이를 통한 통찰력이 어마어마하신 분이셨다.\n척하면 척이고 말했다 하면 예언처럼 이뤄지곤 하는 정말 신기한 분...",
  "content"  : "\n  백부장님의 2가지 가르침을 공유합니다.\n\n\n백부장님은…\n\n\n\n전 회사에서 서버개발자로 함께 일한 분이셨다.\n나와는 두바퀴 띠동갑이셨는데 ‘그냥 형처럼 생각해’라고 말씀하시며 잘 챙겨주셨다.\n금융과 SI쪽에서 굵직한 경력들이 있는 정말로 무협지에 나오는 재야의 고수와 같은 분이셨다.\n코딩도 코딩이지만 짬에서 나오는 도메인 이해와 이를 통한 통찰력이 어마어마하신 분이셨다.\n척하면 척이고 말했다 하면 예언처럼 이뤄지곤 하는 정말 신기한 분이셨는데\n회사에서에서도 핵심 시스템을 유일하게 이해하고 계신 분이셨다. \n\n나에게는 스승과도 같은 존재셨다. 떄때로 정말 많은 조언을 해주셨는데\n퇴사하기 직전에 술 한잔 사주시면서 지금까지도 기억에 남는 두가지 가르침을 남겨주셨다.\n\n\n  ‘이 사람이 무슨 생각일까?’를 항상 고민해라\n  헤게모니를 나의 것으로 만들어라\n\n\n사실 이 가르침을 배운지는 좀 되었지만\n지금까지도 잘 실천하지 못하기도 하고해서\n스스로에게 되새기고자 기억나는 대로 내용을 정리해보았다.\n\n\n\n1. ‘이 사람이 무슨 생각일까?’를 항상 고민해라\n\n\n\n\n\n첫번째 가르침은 바로 대화할 때 말 속의 진짜 의도를 파악하는 것이 항상 중요하다고 말씀해주셨다. \n이는 단순히 단어 뜻대로 해석하는 것이 아니라 이 말을 하는 이유와 목적을 파악해야 한다는 의미였다.\n\n예를 들어 동료가 자신의 실수를 숨기기 위해서 무언가 엉뚱한 요청을 한다던가\n고객이 스스로 무엇이 필요한지 잘 모르는 상태로 도움을 요청하는 경우 등\n말과 실제 목적이 다른 경우가 종종 생기기 마련이기 때문에\n백부장님은 이 말에 속지말고 숨은 속 뜻과 목적을 최대한 해아리는 자세가 필요하다고 하셨다.\n\n나는 이 얘기를 듣고 스티브 잡스가 남긴 이 이야기가 떠올랐다.\n\n\n  대부분 사람들은 제품을 보여주기 전까진 자신들이 원하는 게 뭔지도 정확히 모른다.\n\n\n\n고객의 말을 곧이곧대로 이해하는 대신 진짜로 고객의 니즈를 찾아내야 한다는 교훈을 시사하기도 한다.\n다만 고객 뿐 아니라 동료, 상사, 다른 사람들 조차도 \n정확한 이해 없이 또는 체면이나 다른 이유로 실제 말하는 것과 다른 의도가 있을 수 있다.\n\n사실 나도 비슷한 실수를 많이 했던 기억이 난다.\n사업팀 동료로부터 개발계 테스트앱을 배포해달라는 개인적인 부탁을 받은 적이 있었는데\n당연히 테스트를 위해서일거라 생각하고 내부망에서만 테스트가 가능한 앱을 배포했었다.\n그런데 알고보니 테스트가 필요해서가 아니라 제휴영업을 위해 잠재고객에게 전달할 샘플이 필요한 것이었다.\n결과적으로 두어번의 추가 배포 이후에서야 최종 목적을 듣게되었고 \n그제서야 실제로 편의점에서 시연가능한 운영계 데모앱과 매뉴얼을 전달했다.\n이 일이 있고나서부터는 배포 부탁을 받으면 배포이유를 꼭 듣고 배포를 하게 되었다.\n\n이 가르침은 최대한 몸에 배도록 노력하지만 \n지금도 가끔씩 ‘아차!😧’ 하며 되새길 때가 있다.\n\n\n\n\n2. 헤게모니를 나의 것으로 만들어라\n\n\n\n\n\n헤게모니란?\n\n백부장님은 헤게모니란 표현을 많이 사용하셨는데 여기서는 쉽게 주도권 정도의 의미로 이해하면 된다. \n\n\n다시 말해 헤게모니를 나의 것으로 만들어라는 주도권을 가져오란 뜻인데\n좀 더 구체적으로 이야기하자면 도메인과 시스템의 이해를 통해 업무 관계자들 사이에서 주도권을 가져오라는 의미다.\n\n헤게모니를 가져오는 방법은 아래와 같았다.\n\n\n\n프로젝트 시작 첫 일주일에 바짝 고생해라\n\n백부장님이 SI를 뛰던 시절에 보통 프로젝트에 처음 투입이 되면\n보통은 처음에 여유롭고 뒤로 갈수록 바빠진다고 하셨다.\n\n하지만 백부장님은 반대로 첫번째 주에 바짝 고생하는 것으로 헤게모니를 가져올 수 있다고 하셨다.\n무슨 소리냐면 첫번째 주에 마치 프로토타이핑 또는 목업처럼 \n프로젝트의 핵심 플로우을 한번 설계해보는 것이다.\n이런 과정을 통해 프로젝트와 시스템에 대한 이해를 갖추고 실제 데이터 흐름을 눈으로 봐서\n설계 단계에서의 실수를 미리 찾아내는 과정이 필요하다는 뜻이다.\n\n백부장님은 이 과정을 \n\n\n  한 싸이클을 돈다\n\n\n\n라고 표현하셨다.\n\n\n한 싸이클을 도는 것이 핵심이다\n\n한 싸이클을 돌았을 때의 효과는 다음과 같다.\n\n\n  시스템에 대한 전체적인 맥락을 이해할 수 있다.\n  설계 단계에서 잘못된 부분을 남들보다 먼저 찾을 수 있다.\n  상세 작업단위에서 난이도를 미리 파악하여 예상 일정을 보다 정확하게 산출할 수 있다.\n\n\n시스템에 대한 전체적인 맥락의 이해가 있다면\n회의와 같은 자리에서 자연스럽게 남들보다 유리한 위치에 있게 되고\n또한 설계 단계에서의 실수를 먼저 찾아서 이후에 발생할 일정 손실을 사전에 막아낼 수 있으며\n어느 작업이 일정을 잡아먹을 지 미리 알고 있게 된다는 것이다.\n\n이러한 과정이 반복되다 보면 어느샌가 팀 내에서 이미 전문가로 인정받으며\n자연스럽게 헤게모니를 가져올 수 있게 된다는 것이 백부장님의 설명이다.\n\n일례로 회의 때, 다른 사람과 시스템에 관해 논쟁이 붙이 마련인데\n이미 이럴 때 나는 해봤으니까 남들보다 훨씬 더 깊게 이해하고 있게되고\n이런 논쟁을 지켜보던 사람들이 결국 자신을 인정할 수 밖에 없게 된다는 것이다.\n\n또 재밌는 점은 이러한 논쟁에서 굳이 설득할 필요 없다고 하셨다.\n\n내가 확신이 있지만 다른 사람이 동의하지 못한다면 굳이 설득하려고 애쓰지 마라\n\n나는 굳이 설득하지 말아야 할 이유를 &#39;틀리면 쪽팔리니까?&#39; 정도로 생각했는데\n백부장님의 답은 &#39;어차피 내가 맞을테니까&#39; 였다.\n\n한 싸이클을 제대로 돌아서 이미 시스템에 대한 이해를 하고 있다면\n상대가 틀린 소리라는걸 알고 있다 하더라도 모두가 이 사실을 언젠간 알게 될텐데\n굳이 힘들게 설득하려고 애쓸 필요 없다는 것이다.\n\n이런 식의 과정을 몇번 반복하고 나면\n어느샌가 내가 설득하려고 애쓰지 않아도 사람들이 내 말을 신뢰하게 되고\n결과적으로 아까 말한 헤게모니를 가져오게 된다는 것이 백부장님의 설명이다.\n\n그럼 그 헤게모니로 뭘 하면 될까요?\n\n백부장님은 이러한 헤게모니를 보통 일정조율에 사용하셨다고 하셨다\n\n개발자들(특히 SI)에게는 일정이 목숨인데\n적은 공수로 이른바 딜을 하며 필요한 곳에 더 일정을 얻는 식이었다고 하셨다.\n\n난이도 파악이 되어 어떤 요구사항이 시간이 오래걸릴지 알고 있으므로\n클라이언트와의 일정 조율 때 협상에서 훨씬 유리하게 작용한다고 하셨다.\n쉽게 말해 어려운 기능은 좀 덜어내고 쉬운 기능을 좀 얹어주는 식으로\n클라이언트와의 줄다리기로 일정을 벌어낼 수 있다는 뜻이었다.\n\n\n\n\n나의 반성\n\n사실 아직까지도 이 헤게모니에 대한 가르침은 실천하고 있지 못하다.\n\n솔직히 말로는 쉽지만 \n단 일주일만에 시스템의 핵심 플로우를 그려보는 것이 보통일이 아니다.\n\n또한 예상 공수를 산정하는 것 조차 쉬운 일이 아니다.\n\n지금 회사에서 하고 있는 프로젝트 초반에 이런 과정을 거치지 않았고\n결과적으로 지금 뼈빠지게 야근하면서 그때그때 개발하다가 설계상의 미스를 찾곤 한다.\n이것이 나뿐만 아니라 팀 전체에게 결과적으로 영향을 미치게 되는데\n이럴 때 마다 백부장님의 가르침을 떠올리며 반성하게 된다.\n\n이 부분은 습관보다도 노력과 연습이 필요한 가르침인 것 같다.\n"
} ,
  
  {
    "title"    : "코드 한줄로 안드로이드 SharedPreference를 암호화하는 방법",
    "category" : "",
    "tags"     : " ",
    "url"      : "/android,/security/2021/01/24/brick.html",
    "date"     : "January 24, 2021",
    "excerpt"  : "\n  당신의 안드로이드 앱 데이터는 안전한가요?\n\n\n🔐 데이터를 저장할 땐 반드시 암호화가 필요합니다.\n\n\n\nKISA의 개인정보 안전성 확보조치 기준에 따르면 \n주민번호나 비밀번호와 같은 개인 정보를 모바일 단말에 저장할 때는 반드시 모두 암호화 해야합니다.\n\n만약 보안에 민감한 서비스라서 모바일 보안 취약점 검사를 받는다면\n위에 서술된 민감한 정보 뿐 아니라 전화번호, 생년월일, 이름 등을 포함한\n사실상 거의 모든 정보를 암호화 해야합니...",
  "content"  : "\n  당신의 안드로이드 앱 데이터는 안전한가요?\n\n\n🔐 데이터를 저장할 땐 반드시 암호화가 필요합니다.\n\n\n\nKISA의 개인정보 안전성 확보조치 기준에 따르면 \n주민번호나 비밀번호와 같은 개인 정보를 모바일 단말에 저장할 때는 반드시 모두 암호화 해야합니다.\n\n만약 보안에 민감한 서비스라서 모바일 보안 취약점 검사를 받는다면\n위에 서술된 민감한 정보 뿐 아니라 전화번호, 생년월일, 이름 등을 포함한\n사실상 거의 모든 정보를 암호화 해야합니다.\n\n따라서 단말에 저장하는 데이터는 전부 암호화하는 것이 정신건강에 이롭습니다.\n애초부터 암호화 하는 습관을 들이면 더더욱 좋구요 👍\n\n\n👮‍♂️ EncryptedSharedPreferences\n\n\n\nAndroid Jetpack에 포함된 EncryptedSharedPreferences를 이용하면\n복잡한 구현 없이도 손쉽게 SharedPreferences 데이터를 암호화할 수 있습니다. \n갓드로이드킹트팩\n\n비록 알파버전이나 사실상 구글 공식 라이브러리라서 안심하고 사용할 수 있고\n기존의 SharedPreferences를 상속받고 있어서 처음 호출하는 부분만 수정하면\n이후에 데이터를 읽고 쓰는 과정에서의 수정은 아예 없기 떄문에 무척 편리합니다.\n\n실제로 사용해보면 키값과 데이터가 모두 암호화 되는 것을 확인하실 수 있습니다.\n\n그럼 한번 직접 적용해볼까요?\n\n\n\n1. build.gradle(app)에 의존성 추가\n\ndependencies {\n    implementation &#39;androidx.security:security-crypto:1.0.0-alpha02&#39;\n}\n\n\napp 수준의 build.gradle 의 dependencies에 추가해주면 됩니다.\n\n2. 코드상에서 EncryptedSharedPreferences를 호출하기\n\n  val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)\n\n  val sharedPreferences = EncryptedSharedPreferences.create(\n      &quot;secret_shared_prefs&quot;, // 파일이름을 입력하세요\n      masterKeyAlias,\n      context,\n      EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n      EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n  )\n\n  val editor: SharedPreferences.Editor = sharedPreferences.edit()\n\n\nEncryptedSharedPreferences가 이미 SharedPreferences 이므로 이후에는 \n기존에 쉐어드프리퍼런스를 사용하던 곳에서 데이터를 읽고 쓰는 코드는 동일하므로\n별도의 코드 수정 없이 기존에 사용하시던 대로 사용하면 됩니다.\n\n\n🤔 그런데 말입니다\n\nEncryptedSharedPreferences를 적용하고나서 저장한 모든 데이터는 암호화 되겠지만\n이미 평문으로 저장된 데이터를 암호화 해주지는 않습니다 😭\n\n그리고 안타깝게도 보통 이 글을 읽고 계신분이라면 \n이미 배포되어 사용자 단말에 저장된 데이터의 암호화가 필요하신 분들이 많으실 것 같습니다.\n\n이미 배포된 앱이라서 사용자가 데이터를 평문으로 저장하고 있다면\n이 저장된 데이터를 전부 암호화 하는 이관작업이 반드시 필요합니다.\n\n여러가지 방법이 있을 수 있겠지만 이 글에서는 가장 간단한\n\n\n  기존 데이터를 삭제하고\n  새로운 파일에 암호화 해서 복사\n\n\n하는 방법을 소개드리겠습니다.\n\n\n\n📨 기존 데이터 이관하기\n\n기존에 이미 사용하고 있는 데이터를 암호화 하는 문제는 또 별개의 문제입니다\n\n가장 간단한 방법은 기존의 데이터를 전부 암호화하여 복사하고 기존의 데이터를 삭제하여 \n무조건 암호화 된 데이터만 접근하도록 하는 방식입니다.\n\n\n\n  ⚠️ 복사하고 기존 데이터를 삭제하는 방식이므로 암호화 할 파일이름과 기존 파일이름은 달라야 합니다.\n\n\n// 암호화 되지 않은 레거시 데이터\nval legacy = SharedPreferences by mContext.getSharedPreferences(mFile, Context.MODE_PRIVATE)\nval entries = legacy.all.entries\n\n// 모든 데이터를 복사한다.\n// editor는 EncryptedSharedPreferences의 editor \nentries.forEach {\n    when (it.value) {\n        is String -&amp;gt; editor.putString(it.key, it.value as String).apply()\n        is Long -&amp;gt; editor.putLong(it.key, it.value as Long).apply()\n        is Int -&amp;gt; editor.putInt(it.key, it.value as Int).apply()\n        is Float -&amp;gt; editor.putFloat(it.key, it.value as Float).apply()\n        is Boolean -&amp;gt; editor.putBoolean(it.key, it.value as Boolean).apply()\n        is Set&amp;lt;*&amp;gt; -&amp;gt; editor.putStringSet(it.key, it.value as Set&amp;lt;String&amp;gt;).apply()\n    }\n}\n\n\n복사를 다했다면 기존의 평문 데이터를 전부 지워버립시다.\n\nlegacy.edit().clear().apply()\n\n\n\n\n그런데 잠깐, 최소지원이 api23 이라구요? 😱 😱 😱\n\n\n\n네 그렇습니다. \n마시멜로이하는 이 방법으로는 할 수 가 없기 때문에\n결국 새로운 암호화 모듈을 만들어서 구현해야 합니다.😱\n\n문제는 아직까지도 많은 앱들의 23미만의 앱을 지원하고 있기 때문에\n기껏 EncryptedSharedPreferences가 있어도 활용하기가 어렵다는 점이 가장 큰 문제입니다.\n\n🤷‍♂️ 그럼 이제 어떡하죠?\n\n아직 방법이 있습니다. \n\nBrickSharedPreferences를 사용해보세요!\n\nBrickSharedPreferences가 뭔데?\n\n\n\n\n\nApi 레벨 상관 없이 SharedPreferences를 암호화해주는 라이브러리 입니다.\n\nminSdk 14로 낮은 레벨까지 지원하며\n23 이상이라면 제트팩의 EncryptedSharedPreferences를 사용하고\n23 미만이라면 커스텀 암호화 SharedPreferences를 이용하는 보안 라이브러리 입니다.\n\n또한 추가로 위에서 설명한 ‘기존 데이터 이관’을 단 한줄로 해결할 수 있습니다.\n\n1. build.gradle(app)에 의존성 추가\n\ndependencies {\n    implementation &#39;dev.haenara:bricksharedpref:1.0.2&#39;\n    implementation &#39;androidx.security:security-crypto:1.0.0-alpha02&#39;\n}\n\n\n2. 코드상에서 BrickSharedPreferences를 호출하기\n\n// 기존 SharedPreferences를 가져오는 방법에 &quot;Brick&quot;만 앞에 붙이면 된다. \nval mSharedPreferences = getBrickSharedPreferences(fileName, Context.MODE_PRIVATE)\n\n\n기존에 쉐어드프리퍼런스 호출 시에 코틀린에서 사용하던 코드와 거의 유사한데, \ngetSharedPreferences를 \ngetBrickSharedPreferences로 고친 것이 전부입니다.\n\nBrickSharedPreferences도 기존에 쉐어드프리퍼런스를 사용하던 곳에서 데이터를 읽고 쓰는 코드는 동일하므로\n별도의 코드 수정 없이 기존에 사용하시던 대로 사용하면 됩니다.\n\n\n3. 기존 데이터 이관하기\n\n단 한줄이면 됩니다.\n\n// 저장되어 있는 데이터를 전부 암호화\nmSharedPreferences.migrateEncryptedSharedPreferences()\n\n\n요거 한줄이면 해결됩니다.\n\n\n\n\n\n\n\n\n\n\n\n단, 만약 SharedPreferences를 여러 파일로 나누어 사용중이라면\n각각 파일별로 마이그레이션을 호출해줘야 합니다.\n\n이관 작업은 앱 실행 시 딱 한번만 호출해주면 되기 때문에 \nApplication class의 onCreate() 에서 호출해주는 것이 가장 좋습니다.\n\n\n\n4. 실행 예제\n\n\n\nBrickSharedPreferences 레포지토리에 자세하게 설명되어 있으니 \n\n필요하시다면 샘플 앱과 코드를 참고해보시는 것도 좋을 것 같습니다👍\n\n\n\n🚀 결론\n\n모바일 단말에 저장하는 모든 데이터는 암호화 해야합니다.\nBrickSharedPreferences를 이용해서 간편하게 데이터를 암호화 해보세요.\n만약 유용하게 쓰셨다면 깃헙에서 ⭐️스타를 눌러주세요 👍\n\n레퍼런스\n\n\n  EncryptedSharedPreferences - 구글 Android Developer\n  BrickSharedPreferences\n\n\n\n"
} ,
  
  {
    "title"    : "신해나라의 2020년 회고",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2020/12/31/Reviewing_2020.html",
    "date"     : "December 31, 2020",
    "excerpt"  : "\n  다사다난했던 2020년 한해를 돌아봅니다.\n\n\n2020년은 유독 스펙터클한 한해였습니다. 🌈\n\n\n\n회고는 역시 12월 31일에 남겨야 제맛입니다😚\n\n올해는 정말 유독 다사다난한 한해였습니다. 💥\n코로나가 모든 것을 바꿔놓았고 많은 것을 잃었습니다.\n개인적으로도 이직을 포함해서 정말 여러가지 일들이 동시에 일어난 한해였습니다.\n작년의 회고와 비교해봐도 훨씬 더 많은 일들이 있었던 것 같네요.\n\n\n\n\n\n타임 테이블로 본 2020 📅\n\n\n...",
  "content"  : "\n  다사다난했던 2020년 한해를 돌아봅니다.\n\n\n2020년은 유독 스펙터클한 한해였습니다. 🌈\n\n\n\n회고는 역시 12월 31일에 남겨야 제맛입니다😚\n\n올해는 정말 유독 다사다난한 한해였습니다. 💥\n코로나가 모든 것을 바꿔놓았고 많은 것을 잃었습니다.\n개인적으로도 이직을 포함해서 정말 여러가지 일들이 동시에 일어난 한해였습니다.\n작년의 회고와 비교해봐도 훨씬 더 많은 일들이 있었던 것 같네요.\n\n\n\n\n\n타임 테이블로 본 2020 📅\n\n\n\n상반기에는 이직에 초점이 맞춰져 있었습니다.\n연초부터 본격적인 이직 준비를 시작했고\n실제 면접과 채용과제, 코딩테스트 등을 동시에 진행하였습니다.\n약 서류통과 이후 면접과 과제를 동시에 진행한 덕에 굉장히 정신 없는 기간이었습니다.\n결과적으로 5월말부터 지금 회사인 키즈노트에서 근무하게 되었습니다.\n마침 아이가 어린이집에 다니기 시작하여 이미 키즈노트 사용자이기도 했기 때문에 \n더더욱 회사와 서비스에 애착이 갔던 것 같습니다.\n\n하반기에는 기술적 성숙에 초점이 맞춰져 있습니다.\n입사하자마자 Rx스터디를 시작으로 총 1회 사내 스터디와 2회의 세미나를 직접 진행했습니다. \nNextStep에서 진행하는 Effective Kotlin 1기 강좌를 들었습니다. \n사비를 털어 들은 강좌는 비쌌지만 충분히 값어치를 했고 \n덕분에 코틀린을 코틀린스럽게 쓰기 시작했으며 TDD를 실전으로 익혀볼 수 있었습니다.\n\n가을부터는 회사 프로젝트에 본격적으로 투입되며 굉장히 바빴지만\n틈틈히 친한 동생들과 함께 Android Study를 진행하기도 했고\n같은 회사 동료의 추천을 받아 글또 활동을 시작했습니다. \n또한 2020년 한해동안 한빛미디어 서평단활동을 통해 4권의 도서 리뷰도 진행했습니다.\n( 많이 리뷰한 것 같은데 적고보니 소박하네요… 🙄 )\n\n또한 입사한지 반년이 되었는데 그 중에 반이 재택근무로 진행되었습니다. \n개인적으로는 재택근무 하는 회사를 다니는 것이 꿈이기도 했고\n재택근무 덕에 더 많이 일할 수 있었고 동시에 아이를 보면서 일할 수 있어서 만족스러웠습니다. \n\n\n\n기술적 성장 🚀\n\n\n   클린 아키텍터\n   RxJava\n   AAC기반 MVVM\n   TDD\n   Dagger\n\n\n올해 목표였던 기술 스택들을 상당부분 익히고 실제 상용프로젝트에 적용하였습니다.\n올해 초에만해도 어떤 것인지 잘 모르는 것이었는데 이제는 나름 능숙하게 다루고 있습니다.\nDagger는 아직도 학습 중인데 좀.. 어렵네요.. 😢\n\n학습을 위해 책을 읽고 스터디를 진행하고 강의를 들었는데\n이제는 어떤 기술이든 금방 흡수할 수 있겠다는 자신감이 붙었던 것이 큰 장점인 것 같습니다.\n\n아쉬운점이 있다면 다만 너무 테크니컬한 부분에만 초점이 맞춰진 것 같다는 생각이 드네요.\n내년에는 좀 더 원론적인 부분과 내공을 쌓도록 노력해야겠습니다.\n\n\n\n\n\n올해의 목표를 얼마나 달성했을까? 📊\n\n연초에 세운 계획에 따르면 제가 달성한 퍼센트는 아래와 같습니다.\n\n\n  \n    \n      번호\n      이름\n      목표\n      달성률\n      그래프\n    \n  \n  \n    \n      1\n      책읽기\n      1년에 10권 읽기\n      6 / 10권\n      🟩🟩🟩🟩🟩🟩⬜️⬜️⬜️⬜️\n    \n    \n      2\n      합동 프로젝트\n      1개의 합동 프로젝트 완료해보기\n      0 / 1\n      ⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️\n    \n    \n      3\n      안드로이드 개발자 인증서 따기\n      Google Developers Certification 따기\n      0 / 1\n      ⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️\n    \n    \n      4\n      안드로이드 기술스택 학습하기\n      클린아키텍처, RxJava, MVVM, TDD, Dagger\n      4 / 5\n      🟩🟩🟩🟩🟩🟩🟩🟩⬜️⬜️\n    \n    \n      5\n      이력서 쓰기\n      마스터 이력서 작성\n      1 / 1\n      🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩\n    \n    \n      6\n      개인프로젝트 하기\n      4개의 개인프로젝트 및 배포 (스토어, JCenter)\n      1 / 4\n      🟩🟩🟩⬜️⬜️⬜️⬜️⬜️⬜️⬜️\n    \n    \n      7\n      발표하기\n      누적 청중 100명 앞에서 발표하기 (스터디포함)\n      64/100 명\n      🟩🟩🟩🟩🟩🟩⬜️⬜️⬜️⬜️\n    \n    \n      8\n      블로그 운영하기\n      2주에 한번 블로그 글 쓰기\n      18 / 27\n      🟩🟩🟩🟩🟩🟩🟩⬜️⬜️⬜️\n    \n  \n\n\n\n\n깃헙 잔디밭 관리 ☘️\n\n개인 깃헙 계정 잔디밭 현황은 이렇습니다.\n\n\n\n참고로 회사 계정은 이렇습니다.\n올해는 확실히 회사 계정으로 더 열심히 일했군요.\n\n\n\n음… 좀 부끄럽네요.. 😭\n개인 프로젝트에 너무 소홀했던 것 같습니다…\n오히려 취업 준비겸으로 더 많은 잔디를 심었던 것 같습니다.\n내년에는 좀 더 개인프로젝트에 초점을 맞출 필요가 있겠네요 😒\n\n\n\n\n\n총평 📌\n\n\n\n연초에 세운 계획이 무리한 계획이었다고 생각했는데 생각보다 꽤 채운 것 같네요.\n목표는 있었지만 계획이 없었던 부분에서 달성률이 낮게 나온 점은 아쉽습니다.\n그렇지만 개발자로서 가장 많은 성장을 이뤄낸 한해였습니다. \n그러니 나름 자부심을 가질 수 있지 않을까 싶습니다. 😊 \n\n2020년 한해 다사다난 했지만 가장 잘한 일을 꼽으라면 \n새로운 회사에서 좋은 동료들을 만나고 즐겁게 일할 수 있었고 \n새로운 것들 해보고 싶은 것들 마음껏 진행해볼 수 있어서 행복했습니다.\n\n\n\n\n\n무엇보다도 사랑하는 아들이 건강하게 자라주어서 감사한 한해였습니다. 🥰\n이 자리를 빌어 사랑스런 아들과 아내에게 감사의 인사를 전합니다.\n"
} ,
  
  {
    "title"    : "코틀린 코드를 깔끔하게 정리하는 비결 ~ ktlint",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin,/android,/ktlint/2020/12/27/Ktlint-on-your-project.html",
    "date"     : "December 27, 2020",
    "excerpt"  : "\n  ktlint를 적용하는 방법 한방 정리\n\n\nktlint란?\n\n\n\nKtlint는 Kotlin을 위한 Lint로 코드의 coding convention, style guide 준수 여부를 검사해주는 정적 분석 툴입니다. \n\n기본으로 Kotlin Coding Convention을 따르고 있으며\n\nktlint를 적용하여 프로젝트 내의 코드 스타일을 통일하도록 ⚠️강제⚠️할 수 있습니다.\n아래에서 설명하듯이 git commit시에 반드시 kt...",
  "content"  : "\n  ktlint를 적용하는 방법 한방 정리\n\n\nktlint란?\n\n\n\nKtlint는 Kotlin을 위한 Lint로 코드의 coding convention, style guide 준수 여부를 검사해주는 정적 분석 툴입니다. \n\n기본으로 Kotlin Coding Convention을 따르고 있으며\n\nktlint를 적용하여 프로젝트 내의 코드 스타일을 통일하도록 ⚠️강제⚠️할 수 있습니다.\n아래에서 설명하듯이 git commit시에 반드시 ktlint를 통과하도록 강제할 수 있어서\n팀내에서 코드 스타일을 서로 맞추고 싶다면 ktlint 사용을 적극 추천드립니다.\n\n💁‍♂️ 좀 더 자세한 소개는 아래의 ktlint 공식 페이지를 참고해보세요.\n\n\n  Ktlint Page\n  Ktlint Plugin GitHub Repository\n\n\nktlint 도입의 장점\n\n프로젝트 내에서 코드 스타일이 강제로 통일되기 때문에 \n서로 다른 스타일로 작성될 일이 없고 모든 프로젝트 내의 코드가 통일성이 생깁니다.\n\n이를 통해 코드 리뷰 시에 서로 다른 스타일로 인한 피로감이 줄어들고\n가독성 저하 또는 불필요한 소통의 비용이 줄어들게 됩니다.\n\n현재 제가 직장에서 담당하고 있는 안드로이드 프로젝트에서 ktlint를 적용하고 있는데\n실제로 서로 코드 스타일이 비슷해지다보니 다른 개발자의 PR 코드리뷰 때 좀 더 눈에도 잘 들어오고\n한줄에 너무 길게 쓴다던가 하는 일도 없어지고\n누가 언제 짠 코드이던 비슷하게 생겨서 어느 장단에 맞춰야 할지 고민할 일이 없어져서 좋습니다.\nreformat code를 습관적으로 하게 되는 것도 큰 장점인 것 같습니다.\n\n다만 초창기에 팀원들의 동의를 받아야하며, 적응기간이 아주 약간 있으니 이점은 유의해야 합니다.\n\n\n\n\n\n\n\n🚀 ktlint 프로젝트에 적용 준비하기\n\n\n\n  개발자가 깨끗하게 해야할 것은 키보드 뿐만이 아닙니다.\n\n\n\n\n프로젝트에 ktlint 적용하는 방법입니다.\n\n\n\n1. build.gradle(root) 수정하기\n\n\n  최상단에 plugin org.jlleitschuh.gradle.ktlint 을 추가합니다.\n  레포지토리에 maven https://plugins.gradle.org/m2/ 을 추가합니다.\n  classpath 의존성에 org.jlleitschuh.gradle:ktlint-gradle 를 추가합니다.\n\n\n\n  작성일 기준 최신 버전은 9.4.1 입니다. \n예제에서는 9.3.0을 사용했지만 어느 버전을 사용해도 무관합니다.\n\n\n\n\n다 적용한다면 아마 아래와 같은 모양이 될 겁니다.\n\napply plugin: &#39;org.jlleitschuh.gradle.ktlint&#39;\n\nbuildscript {\n\n...중략...\n\n    repositories {\n        maven {\n            url &quot;https://plugins.gradle.org/m2/&quot;\n        }\n    }\n\n...중략...\n\n    dependencies {\n        classpath &quot;org.jlleitschuh.gradle:ktlint-gradle:9.3.0&quot;\n    }\n}\n\n\n\n\n  💁‍♂️  위에만 봐서는 이해가 잘 안된다면 샘플 코드를 참고해보세요.\n\n\n\n\n2. build.gradle(android module) 수정하기\n\n안드로이드 app 모듈에 추가하는 방법입니다. \n\n\n  최상단에 plugin org.jlleitschuh.gradle.ktlint 를 추가합니다.\n  ktlint 설정값을 추가합니다.\n\n\n\n  예제에서 설정값은 가장 무난한 설정값으로 했습니다. \n공식페이지 설명을 보고 프로젝트에 맞게 설정을 수정해보세요.\n\n\n\n\n다 적용한다면 아마 아래와 같은 모양이 될 겁니다.\n\n\n\nplugins {\n    id &#39;org.jlleitschuh.gradle.ktlint&#39;\n}\n\n... 중략 ...\n\nktlint {\n    android = true\n    outputColorName =&quot;RED&quot;\n    verbose = true\n    disabledRules.addAll(&quot;import-ordering&quot;)\n}\n\n\n\n  💁‍♂️  위에만 봐서는 이해가 잘 안된다면 샘플 코드를 참고해보세요.\n\n\n\n\n3. build.gradle(non-android module) 수정하기\n\n순수 Java/Koltin(JAR) 모듈에 추가하는 방법입니다. \n\n\n  최상단에 plugin org.jlleitschuh.gradle.ktlint 를 추가합니다.\n  ktlint 설정값을 추가합니다.\n\n\n\n  안드로이드 모듈과 다 동일한데 android = false인 것만 유의해주세요.\n\n\n\n\nplugins {\n    id &#39;org.jlleitschuh.gradle.ktlint&#39;\n}\n...\nktlint {\n    android = false\n    outputColorName =&quot;RED&quot;\n    verbose = true\n    disabledRules.addAll(&quot;import-ordering&quot;)\n}\n\n\n\n  💁‍♂️  위에만 봐서는 이해가 잘 안된다면 샘플 코드를 참고해보세요.\n\n\n\n\n이제 적용이 다 되었다면 실제로 ktlint를 한번 써 봅시다!\n\n\n\n\n🛠 ktlint 적용하기\n\n\n\n  코드를 청소할 시간입니다.\n\n\n\n\n1. 수동으로 Ktlint 체크하기 🔍\n\nktlint를 적용하게 되면 수시로 체크하게 되는데요\n언제든지 아래와 같이 수동으로 코딩스타일을 준수하고 있는 지 확인할 수 있습니다.\n\nAndroid Studio의 Gradle 탭에서 다음 Task를 실행합니다.\n\n\n  MyProject &amp;gt; Tasks &amp;gt; verification &amp;gt; ktlintCheck\n\n\n\n\n또는 콘솔에서 아래와 같이 입력합니다.\n\n./gradlew ktlintCheck\n\n\n\n\n만약 고쳐야 할 것이 있다면 아래와 같이 나옵니다.\n\n\n\n나름 친절하게 어느 코드 라인에서 틀렸는지 알려주며,\n그 옆에 괄호로 왜 틀렸는지도 알려줍니다.\n\n다시 다 수정하고 고칠 것이 없다면 아래와 같이 통과하여 Success 합니다.\n\n\n\n\n\n2. Commit시 Ktlint 체크 적용하기 (Git hook) 🎣\n\n매번 수동으로 체크할수는 없겠죠?\n아래와 같이 git-hook에 적용하고 나면 commit 할 때마다 ktlint를 체크하여\n스타일을 준수하지 않았다면 커밋이 실패하게 됩니다.\n\nAndroid Studio의 Gradle 탭에서 다음 Task를 실행합니다.\n\n\n  MyProject &amp;gt; Tasks &amp;gt; help &amp;gt; addKtlintCheckGitPreCommitHook\n\n\n\n\n또는 콘솔에서 아래와 같이 입력합니다.\n\n./gradlew addKtlintCheckGitPreCommitHook\n\n\n\n\n성공적으로 적용되었다면 어디에서 commit을 하더라도 \n반드시 ktlint가 통과되어야 commit이 됩니다.\n\n\n\n  소스트리에서 commit 해도 마찬가지로 ktlint가 통과되어야만 합니다.\n\n\n\n\n⚠️ 잠깐! 혹시 에러가 나진 않나요?\n\n\n  Execution failed for task ‘:addKtlintCheckGitPreCommitHook’.\njava.io.IOException: No such file or directory\n\n\n만약 위와 에러가 발생한다면 .git 디렉토리 하위에 hooks 가 없어서 발생하는 것이니 hooks 디렉토리를 생성합니다.\n\nmkdir .git/hooks\n\n\n\n\n3. Android Studio formatter를 Ktlint에 맞게 설정 하기 🛠\n\n이제부터는 수시로 reformat code를 호출하게 될 텐데, \n안드로이드 스튜디오가 kotlin convention을 따르지 않아서 \n오히려 반대로 자꾸 엉뚱한 스타일로 바꿔버리면 곤란하겠죠?\n아래 방법대로 안드로이드 스튜디오의 코틀린 포맷을 ktlint와 동일하게 맞춰봅시다.\n\nAndroid Studio의 Gradle 탭에서 다음 Task를 실행합니다.\n\n\n  ClassNote &amp;gt; Tasks &amp;gt; help &amp;gt; ktlintApplyToIdea\n\n\n\n\n또는 콘솔에서 아래와 같이 입력합니다.\n\n./gradlew ktlintApplyToIdea\n\n\n\n\n주로 틀리는 것들 📌\n\n주로 틀리는 것들이 있는데, 이 부분은 Android Studio 설정을 조금만 바꿔주면 해결됩니다.\n\n\n\n1. 파일의 끝은 new-line 으로 끝나야 합니다.\n\n파일의 끝은 반드시 줄내림으로 끝내야 합니다.\n\n그 이유는 콘솔에서 diff나 git 등으로 코드를 보거나 할 때 줄내림이 없으면\n마지막 줄이 콘솔에서는 한줄로 보여서 문제가 되기 때문이라고 합니다.\n\nPreferences &amp;gt; Editor &amp;gt; General 페이지의 Save Files 항목에서\n\nEnsure an empty line at the end of a file on save를 체크하세요.\n\n\n\n\n2. Wild-card imports\n\nPreferences &amp;gt; Editor &amp;gt; Code Style &amp;gt; Kotlin &amp;gt; Imports 항목에서\n\nTop-level symbols와 Java Statics and Enum Members 를 모두\n\nUse Single name import로 고쳐주시면 됩니다.\n\n\n\n\n\n3. Continuation indent (이어지는 들여쓰기)\n\nAndroid Studio에서 줄이 이어지는 경우 들여쓰기가 8칸이 기본값이기 때문에 수정이 필요합니다. \n\nPreferences &amp;gt; Editor &amp;gt; Code Style &amp;gt; Kotlin &amp;gt; Tabs and Indents 항목에서\n\nContinuation indent 항목을 4로 수정해주세요.\n\n\n\n\n\n😎 예제가 필요하시다면…\n\n혹시 이 글로만 이해가 잘 안되고 예제 프로젝트가 필요하시다면\n제가 미리 만들어둔 프로젝트가 있으니 아래 링크로 확인해보세요\nhttps://github.com/HaenaraShin/Ktlint-Android-Sample\n\n\n"
} ,
  
  {
    "title"    : "당신의 프로젝트에 Kotlin을 적용하지 말아야할 3가지 이유",
    "category" : "",
    "tags"     : " ",
    "url"      : "/kotlin,/java,/android/2020/12/13/Why_not_kotlin.html",
    "date"     : "December 13, 2020",
    "excerpt"  : "\n  프로젝트에 Kotlin 도입 전 신중하게 고려해야 할 이유 3가지\n\n\n\n\nKotlin 도입\n\nKotlin은 Java와 마찬가지로 class파일로 바이트코드로 빌드가 가능하기 때문에 \n일반적인 경우에 결과물은 Java와 100% 호환된다고 할 수 있습니다.\n\n특히나 Android 진영에서는 다음 Kotlin은 필수처럼 여겨집니다.\n\n\n  2017년 : Kotlin Android 공식 언어로 채택 (Google I/O)\n  2019년 :...",
  "content"  : "\n  프로젝트에 Kotlin 도입 전 신중하게 고려해야 할 이유 3가지\n\n\n\n\nKotlin 도입\n\nKotlin은 Java와 마찬가지로 class파일로 바이트코드로 빌드가 가능하기 때문에 \n일반적인 경우에 결과물은 Java와 100% 호환된다고 할 수 있습니다.\n\n특히나 Android 진영에서는 다음 Kotlin은 필수처럼 여겨집니다.\n\n\n  2017년 : Kotlin Android 공식 언어로 채택 (Google I/O)\n  2019년 : Kotlin-First (코틀린 우선) 정책 발표\n\n\n\n모두들 코틀린이 좋은 이유는 구구절절 설명해주지만\n코틀린을 왜 적용하지 말아야 하는지는 아무도 얘기해 주지 않아서 \n\n지금부터 아무도 얘기해주지 않는 코틀린 도입을 미뤄야 할 3가지 이유를 소개해보고자 합니다.\n\n1. 소스 코드 레벨의 솔루션\n\nKotlin과 Java는 결과물이 호환이지, 소스코드가 호환인 것은 아닙니다.🙅‍♂️\n\n즉 빌드한 다음에야 Kotlin으로 만든 class를 Java에서도 참조할 수 있지만,\nJava파일에 Kotlin 코드를 붙여넣는다고 동작하지는 않습니다.\n(물론 갓텔리제이가 변환해주기는 합니다… 갓브레인즈 충성충성 ^^7)\n\n만약 당신의 프로젝트에 소스코드 취약점 분석과 같은 소스코드 레벨의 정적분석 툴을 사용하고 있다면,\n그리고 그 해당 솔루션이 아직 Kotlin을 지원하지 않는다면 아직은 고민해 볼 필요가 있습니다.\n\n실제로 올해초에 소스코드 취약점 분석 툴을 검토했었는데 \n그 당시엔 Kotlin 미지원으로 인해 조금 난감했던 기억이 있습니다.🤦‍♂️\n\n\n\n2. 학습 비용 대비 성능\n\n사실 Kotlin을 쓴다고 해서 당신의 어플리케이션이 더 빨라지지는 않습니다.\n그런데 굳이 성능이 좋아지지 않는데 힘들게 새로운 언어를 배우는 일은 가성비가 떨어지는 일입니다.\n개발자에게 새로운 프로그래밍 언어를 배운다는 사실은 굉장히 부담스러운 일이니까요. 그쵸?\n\n\n\n3. 채용난이도\n\n저도 실제로 경험해봤지만..\n당신이 만약 영세한 기업을 다니고 있다면 코틀린을 할 줄 아는 개발자를 찾기란 참 어려울 수 있습니다.\n코틀린 사용할 줄 아시는 분을 찾다가 인력충원이 늦어질 수도 있는 셈이죠.\n현실적으로는 빨리 Java라도 할 줄 아는 분을 뽑아서 협업하는 편이 나을 수 있습니다.\n\n\n\n결론 :\n\n코틀린 쓰세요.. 그냥 쓰세요..\n\n \n\n\n  사실 이 포스팅은 당신에게 코틀린을 쓰지 말라고 권장하는 글이 아닙니다.\n\n\n\n\n사실 제목은 페이크였고… \n지금부터 다시 위 항목들을 조목조목 반박해보며 \nKotlin을 도입을 미루는 핑계에 대한 반박 3가지를 말씀드립니다.\n\n\n\n1. 소스코드 레벨의 솔루션\n\n사실 이미 정적 분석툴을 사용하고 있고 정말로 Kotlin을 지원하지 않는다면 곤란하긴 합니다.\n하지만 적어도 국내 코드 취약점 분석 솔루션 제공업체들은 늦어도 올 하반기 Kotlin 지원 예정이었습니다.\n\n만약 그대로 어렵다면 아래와 같이 오픈소스 분석 툴을 사용하는 것도 방법이 될 수 있습니다. \n\nDetekt\n\n \n\n\n  Detekt 공식 페이지\n  GitHub 링크\n\n\n\n\nDetekt는 오픈소스 Kotlin 정적 분석 툴로써 \nKotlin 소스 코드의 코드 스멜과 잠재적 위협요소들을 분석해줍니다. \n\n\n물론 보안상의 기준은 상용 솔루션에 비하면 낮은 편이지만 오픈소스인걸 고려하면 도입은 충분히 검토해볼만 합니다.\n\n또한 Proguard, Allaotori 등 난독화 솔루션의 경우는 이미 대부분이 Kotlin을 지원하고 있는데\n정말 중요한 솔루션이라면 대부분 이미 Kotlin을 지원하고 있다고 보셔도 무방합니다.\n\n\n\n2. 학습 비용 대비 성능\n\nKotlin을 쓴다고 해서 당신의 어플리케이션이 더 빨라지지는 않습니다.\n하지만 더욱 중요한 사실은 \nKotlin을 사용한다고 해서 당신의 어플리케이션이 느려지지 않습니다. \n\nif Kakao 2018 에서 발표한 내용을 참고하자면 실제로 성능이 거의 동일하다고 합니다.\n\n즉, 코틀린 도입을 통해 성능을 유지하면서 생산성은 대폭 향상됩니다!!\n\n아까 참조한 if Kakao 2018 에서 발표에서도 60% 이상 코드가 줄어드는 것을 확인하실 수 있다고 하는데\nKotlin을 사용하면 훨씬 더 간결하고 명확한 코딩이 가능합니다.\n\n생산성과 관련해서는 다른 곳에서도 쉽게 찾을 수 있는 내용이니 나중에 기회가 된다면 설명하도록 하겠습니다.\n\n그리고.. 설마 개발자면서 새로운 언어 배우는게 그렇게 힘들고 싫겠어요? 😉\n\n\n\n3. 채용난이도\n\n네. 아직까지도 Kotlin을 다룰 줄 모르시는 분들도 많고, Java로 프로젝트를 진행하는 회사도 많습니다.\n그치만 Kotlin을 도입한다면 앞으로 Kotlin을 할 줄 알거나, 최소한 학습하려는 사람과 일하게 될 것입니다.\n\n반대로 내가 Kotlin을 할 줄 모른다면, 나도 Kotlin을 다루는 회사로 갈 기회를 잃는 셈입니다.\n\n재결론 :\n\n \nKotlin 쓰세요. 두번 쓰세요.\n\n\n\n"
} ,
  
  {
    "title"    : "내가 TDD를 실패했던 3가지 이유",
    "category" : "",
    "tags"     : " ",
    "url"      : "/tech,tdd/2020/11/29/How-to-tdd.html",
    "date"     : "November 29, 2020",
    "excerpt"  : "\n  TDD를 배우는 과정에서 어려웠던 점과 해결책을 공유합니다.\n\n\n🤷‍♂️ TDD가 뭔데?\n\n\n\n테스트 주도 개발 (TEST DRIVEN DEVELOPMENT)\n\n테스트 주도 개발이란 켄트 벡이 정의한 개발 프로세스로서\n\n테스트 코드를 먼저 작성하고 해당 테스트를 통과하는 코드를 작성하는 과정을 짧고 빠르게 반복하는 SW 개발 프로세스\n\n를 의미합니다.\n\nTDD의 3단계\n\n\n  RED -&amp;gt; GREEN -&amp;gt; REFACTORIN...",
  "content"  : "\n  TDD를 배우는 과정에서 어려웠던 점과 해결책을 공유합니다.\n\n\n🤷‍♂️ TDD가 뭔데?\n\n\n\n테스트 주도 개발 (TEST DRIVEN DEVELOPMENT)\n\n테스트 주도 개발이란 켄트 벡이 정의한 개발 프로세스로서\n\n테스트 코드를 먼저 작성하고 해당 테스트를 통과하는 코드를 작성하는 과정을 짧고 빠르게 반복하는 SW 개발 프로세스\n\n를 의미합니다.\n\nTDD의 3단계\n\n\n  RED -&amp;gt; GREEN -&amp;gt; REFACTORING 3개의 사이클을 반복하며 각각의 스텝이 의미하는 바는 아래와 같습니다.\n\n\n1. RED : 실패하는 테스트 코드를 작성\n2. GREEN : 테스트 코드를 어떻게든 성공하도록 수정\n\n3 REFACTORING : 테스트 성공하는 채로 리팩토링으로 개선\n\n\n👍 TDD의 장점\n\n일반적으로 TDD를 통해 얻을 수 있는 것들은 아래와 같습니다.\n\n\n  😊 심리적 안정감과 자신감\n  ⚖️ 테스트 코드로 코드의 안정성\n  🛠 리팩토링 하기 좋은 구조의 코드\n  🎯 테스트 코드 작성 과정에서 요구사항 도출\n\n\n클린아키텍처 저자 엉클밥은 TDD로 짜는게 그냥 짜는 것 보다 빠르다는\n\n그야말로 🛢고인물스러운 주장을 합니다… 😇\n\n\n\n😭 내가 TDD를 실패한 이유\n\n\n\nTDD가 뭔지 학습한 뒤 본격적으로 연습해보고자 자신있게 프로젝트를 생성했지만..\n\n정작 코드를 작성하려고 하자 손이 탁 멈춰버렸고 한줄도 제대로 짜지 못했습니다. 😢\n\n분명 단위테스트를 작성하는 것에는 익숙했지만 이상하게 TDD를 의식하자 코드가 나오질 않았습니다.\n\n\n\n🤔 왜 실패했을까?\n\n이후에 다시 분석한 실패 요인은 3가지 였습니다.\n\n\n  너무 어려운 예제로 시작했다.\n  요구사항을 정리하지 않았다.\n  순환 논리의 오류에 빠졌다.\n\n\n\n\n♻️ 순환 논리의 오류?\n\n테스트 코드를 막상 짜려고하자 내 머릿속에서 이런 의문들이 떠오르고 혼란에 빠지고 말았습니다.😱\n\n\n  구현 코드가 있어야 그에 대한 테스트 코드를 작성할 수 있는거 아닌가?\n\n\n\n  구현코드 없이 테스트 코드를 어떻게 작성하지?\n\n\n\n  그렇다고 구현 코드를 작성하고 테스트코드를 작성하면 TDD가 아니잖아?\n\n\n\n  뭐 부터 시작하는게 맞는거야?\n\n\n단순히 RED -&amp;gt; GREEN -&amp;gt; REFACTORING 3개의 스텝만으로는 설명이 충분치 않았습니다.\n\n스텝별로 좀 더 상세히 알아보도록 합시다.\n\n\n\n💁‍♂️ 실전 TDD\n\n\n\n1. README에 요구사항을 한국어로 정리\n\n문장으로 정리함으로써 요구사항을 구체화하고 도출해내는 과정입니다.\n\n\n  코드레벨에서 구현해야 할 요구사항을 한국어로 정리합니다.\n  최대한 많이, 구체적으로 적습니다.\n  클래스와 함수를 의식하지 말고 기능단위로 적습니다.\n  이후 여기서 적은 기능 요구사항들을 그대로 테스트 코드로 작성합니다.\n\n\n\n\n2. 컴파일 에러가 나는 테스트코드를 작성 \n\n\n  아직 작성하지 않은 클래스와 함수를 상상력으로 작성해나가며 테스트 코드를 작성합니다.\n  결과적으로 이 단계에서는 컴파일 에러가 나는 상태가 됩니다.\n  필자는 그냥 pseudo code라고 받아들이니까 편하게 짤 수 있었습니다.\n\n\n\n\n3. 누락된 코드를 구현\n\n\n  미구현 된 코드를 채워나가며 컴파일 에러만 해결합니다.\n    \n      즉 실행 가능한 (그러나 실패하는) 테스트 코드로 수정합니다.\n    \n  \n  내부 로직을 구현할 필요 없이 테스트 실행이 가능하게만 짜면 됩니다.\n\n\n\n\n4. 테스트 실행해서 Fail을 확인\n\n\n  테스트를 실행하고 결과로 Fail 을 눈으로 확인합니다.\n  이 과정을 생략하고 싶은 유혹이 자주 오지만 반드시 확인해야 합니다.\n    ✋ 잠깐! 왜 굳이 결과로 Fail을 봐야해?\n  \n\n\n\n  Unit 테스트는 디폴트가 성공이므로 테스트 코드에 버그가 있어서 실수로 성공 해버린다면\n이후에 다음 스텝에서 테스트가 성공해도 정말로 로직을 잘 짠건지 검증이 불가능해지기 때문!\n\n\n\n\n5. 테스트 결과를 어떻게든 Success 로 만든다.\n\n\n  무슨 짓(죄악😈)을 해서라도 일단 테스트 결과가 Success가 나게끔 만듭니다.\n  결과적으로 테스트 코드가 잘 동작한다는 정도만 검증합니다.\n\n\n😈 죄악이란?\n\n\n  코드 중복, 하드 코딩 등을 이용하여 그야말로 주어진 테스트만 간신히 성공 하게 만듭니다.\n  실제 코드 로직을 구현하는 대신 입력과 출력의 형식 정도만 맞춥니다.\n\n\n예를 들면 아래와 같은 sum()이란 함수를 검증한다고 가정합니다.\n\nassertEquals(4, sum(2, 2))\n\n\n이 경우에 죄악 예시는 sum()이 4를 반환하도록 하드코딩 하는 것입니다.\n\nfun sum(a: Int, b: Int): Int {\n    return 4\n} \n\n\n결과적으로 assertEquals(4, sum(2, 2)) 테스트는 성공을 하게 됩니다.\n\n\n\n6. 코드를 리팩토링\n\n\n  테스트 결과를 Success 유지하는 채로 코드를 리팩토링합니다.\n  전 단계에서 저지른 죄악(코드 중복, 하드 코딩 등)을 속죄하는 단계 👼\n  이 단계부터는 실제 상용 코드를 구현 합니다.\n  반복해서 테스트를 돌려가며 리팩토링 해나갑니다.\n  필요에 따라서는 테스트 케이스를 추가하고 프로세스를 반복합니다.\n\n\n\n\n7. 반복\n\n충분히 안심이 된다면 다음 로직을 2단계부터 반복합니다.\n\n\n\n🚀 더 나은 TDD를 위한 Tip\n\n\n  연습이 많이 필요합니다.\n  테스트 짜기 쉬운 것 부터 시작해봅시다.\n  메소드추출, 클래스 생성 등 IDE 기능을 최대한 활용합니다. (젯브레인 충성충성 ^^7)\n  ⚠️모든 케이스를 반드시 검증 해야하는 것은 아닙니다.\n    \n      테스트 코드는 꼭 많은 것이 좋은 것은 아닙니다.\n      테스트 코드가 너무 많으면 오히려 리팩토링이 부담스러워 집니다.\n      본인 스스로 리팩토링 할 때 안심될 수준을 권장합니다.\n      Private 함수는 테스트 할 필요가 없습니다.\n    \n  \n\n\n\n📐 OOP vs TDD vs Refactoring 삼각관계\n\n객체지향, TDD, 리팩토링은 모두 밀접한 연관관계를 갖게 됩니다.\n\n프로젝트의 상황, 개발자의 역량과 숙련도에 따라 이 연관관계가 절망이 될 수도, 희망이 될 수도 있습니다.\n\n절망편\n\n\n\n희망편\n\n\n\n\n\n🦄 결론\n\nTDD는 많은 연습을 필요로 하지만 단계별로 차근차근 해본다면 어렵지 않을 거에요\n\n여러분도 TDD를 통해서 안정적이고 리팩토링하기 좋은 코드를 해보시기 바랍니다. 😊\n"
} ,
  
  {
    "title"    : "[도서리뷰] 스위프트 프로그래밍 리뷰",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2020/11/15/swift_review.html",
    "date"     : "November 15, 2020",
    "excerpt"  : "\n  한빛 미디어 서평단 활동의 일환으로 작성된 리뷰입니다.\n\n\n💁‍♂️ 이 책을 소개합니다.\n\n오늘 소개할 책은 스위프트 프로그래밍입니다.\n\n\n✏️ 요약하자면\n\n\n  근본있고 싶은 iOS 개발자에게 추천하는 책\n\n\n\n\n이 책에서 가장 놀라운 점은 iOS에 대해 다루지 않는 다는 점입니다.\n\n사실 스위프트를 왜 배우는 지 물어본다면 100명중 98명정도는 iOS 개발을 하고 싶어서라고 대답할 텐데\n\n이 책은 iOS가 아닌 순수하게 스위프트...",
  "content"  : "\n  한빛 미디어 서평단 활동의 일환으로 작성된 리뷰입니다.\n\n\n💁‍♂️ 이 책을 소개합니다.\n\n오늘 소개할 책은 스위프트 프로그래밍입니다.\n\n\n✏️ 요약하자면\n\n\n  근본있고 싶은 iOS 개발자에게 추천하는 책\n\n\n\n\n이 책에서 가장 놀라운 점은 iOS에 대해 다루지 않는 다는 점입니다.\n\n사실 스위프트를 왜 배우는 지 물어본다면 100명중 98명정도는 iOS 개발을 하고 싶어서라고 대답할 텐데\n\n이 책은 iOS가 아닌 순수하게 스위프트와 스위프트의 특징인 3가지 패러다임에 초점을 맞추고 있습니다\n\n\n  객체지향 패러다임\n  함수형 패러다임\n  프로토콜 지향 프로그래밍\n\n\n프레임워크로 부터 독립적으로 순수하게 스위프트 자체에 초점이 맞춰져있기 때문에\n\n오히려 함수형 프로그래밍을 입문하기에 최적의 책이 아닐까 싶습니다.\n\n👀 이렇게 읽어보세요\n\n\n  개발이 처음이라면 정말 프롤로그부터 차근차근 예제를 따라해보세요.\n  함수형 프로그래밍을 제대로 배워보고 싶다면 챕터13 부터 반드시 집중해서 읽어 보세요.\n  프로토콜 지향 프로그래밍이 궁금하다면 챕터20 부터 읽어보세요.\n\n\n👍 이런 사람에게 추천 합니다!\n\n\n  iOS 개발을 1년~3년 정도 해보고 지금 이게 맞나 싶은 순간이 왔다면 이 책을 읽어보세요\n\n\n\n  iOS 개발을 하고 있는데 스위프트가 무서워서 아직 도전해보지 못했다면 이 책을 추천합니다.\n\n\niOS 프레임워크에만 빠져서 재밌는 개발이 무엇인지 까먹었다면?\n\nObjective-C 로도 충분한데 굳이 스위프트를 왜 배워야 하는지 잘 모르겠다면?\n\n아직도 스위프트를 Objective-C 스럽게 짜고 있다면?\n\n\n\n이 책을 통해 함수형 프로그래밍과 프로토콜 지향 프로그래밍스러운\n\n그야말로 스위프트스러운 프로그래밍을 해보고 싶은 분들이라면\n\n이 책을 추천드립니다 👍\n"
} ,
  
  {
    "title"    : "개발자가 블로그로 세상을 바꾸는 방법",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2020/11/15/Geulddo-starting.html",
    "date"     : "November 15, 2020",
    "excerpt"  : "\n  글또 5기 활동을 시작하며 작성하는 첫 다짐글 입니다.\n\n\n💁‍♂️ 글또란?\n\n\n\n\n\n\n  글또란 ‘글 쓰는 또라이가 세상을 바꾼다’는 구호 아래 \n여러 개발자가 모여 블로그 글을 꾸준히 작성하고 서로 격려하는 커뮤니티 입니다.\n\n\n이전에 운영하던 워드프레스 블로그에서 깃헙 블로그로 새로 이전하게 된\n\n가장 큰 계기가 바로 글또활동을 시작하게 된 것입니다.\n\n✏️ 내가 글을 쓰는 이유\n\n\n  좋은 개발자는 좋은 작가다.\n\n\n글을 쓰게...",
  "content"  : "\n  글또 5기 활동을 시작하며 작성하는 첫 다짐글 입니다.\n\n\n💁‍♂️ 글또란?\n\n\n\n\n\n\n  글또란 ‘글 쓰는 또라이가 세상을 바꾼다’는 구호 아래 \n여러 개발자가 모여 블로그 글을 꾸준히 작성하고 서로 격려하는 커뮤니티 입니다.\n\n\n이전에 운영하던 워드프레스 블로그에서 깃헙 블로그로 새로 이전하게 된\n\n가장 큰 계기가 바로 글또활동을 시작하게 된 것입니다.\n\n✏️ 내가 글을 쓰는 이유\n\n\n  좋은 개발자는 좋은 작가다.\n\n\n글을 쓰게 된 결정적인 계기라고 한다면 정도현(정개발)님의 이 말씀 덕분이었습니다.\n\n여러 개발자 컨퍼런스를 다니다 어느순간 존경하는 시니어 선배님들께서\n\n칼럼이나 책 또는 블로그를 꾸준히 쓰고 있다는 것을 발견하였습니다.\n\n저 역시 20년 뒤에 시니어가 되었을 때 선배 개발자들처럼 후배 개발자들에게\n\n코드와 글로써 공헌할 수 있는 시니어가 되고자 합니다.\n\n그리고 그런 시니어가 되기 위해 꾸준한 블로그 활동을 통해서 작문 실력을 키우고자 합니다.\n\n🌏 글로 바꾸는 세상\n\n개발자 생태계의 독특한 점 중 하나는 ‘나누는 것’을 좋아한다는 것입니다.\n\n노하우를 혼자만 알고 있는 대신 오픈 소스나 개발 블로그와 같이\n\n다른 사람들과 공유하는 채널이 다른 직군에 비해 상당히 발달해 있습니다.\n\n글또 멤버들의 글과 제가 작성한 글들이 하나하나는 작은 변화겠지만 모든 글이 누적된다면\n\n결과적으로는 상당한 양의 글과 노하우가 개발자 생태계에 기여하는 셈이 됩니다.\n\n특히 영어에 비해 정보가 부족한 한국인 개발자 생태계에 단비가 되기를 기대해 봅니다.\n\n그리고 제 커리어에도 좋은 영향이 있지 않을까… 기대해봅니다. 😊\n\n⭐️ 앞으로 글을 쓰는 다짐\n\n사실 다른 글또 멤버들에게 리뷰를 받는다는 점 때문에\n\n조금이라도 더 길게 그리고 그럴싸하게 글을 써야 한다는 생각을 버릴 수가 없었는데…\n\n매일매일 바쁘게 살아가는 직장인으로서 오히려 2주에 한 번 힘주어 글을 쓰는 것 보다\n\n차리리 힘 빼고 짧은 글을 매일 쓰는 편이 장기적으로 유리할 것 같다는 생각이 듭니다.\n\n지금 당장은 좋은 글을 쓰기보다 꾸준한 글을 쓰는 것이 중요하니까요.\n\n물론 가끔은 좋은 글을 위해 시간투자해야겠지만요 😅\n\n그래서 매일 잔디밭도 심을 겸 (GitHub 블로그의 최대 장점👍)\n\n앞으로 매일매일 짧은 토막글을 써보고자 합니다.\n\n다만 토막글을 모아서 하나의 포스팅으로 작성하므로 글이 매일 업로드 되지 않을 수 있습니다.\n"
} ,
  
  {
    "title"    : "JAR 라이브러리 뜯어고치기 (.class 바이트코드 수정)",
    "category" : "",
    "tags"     : " ",
    "url"      : "/android/2020/10/07/decomplie-jar.html",
    "date"     : "October 7, 2020",
    "excerpt"  : "\n  이번 포스팅에서는 JAR 안에 빌드된 바이트코드(.class)를 수정하는 방법을 소개합니다.\n\n\n\n\n\n\nJava 개발자로서 살다보면 자주는 아니지만\n이미 빌드가 완료된  JAR 파일의 바이트코드를 수정해야 하는 일이 생길 수 있다.\n(없다면 다행이고… 🙄)\n\n정말 피치 못할 사정때문에 해야한다면 아래 방법을 참고해보자.\n\n0. 🎬 사전 준비\n바이트코드를 수정할 수 있는 에디터 JBE를 준비한다.\n\n바이트코드 에디터는 여기 에서 다운로...",
  "content"  : "\n  이번 포스팅에서는 JAR 안에 빌드된 바이트코드(.class)를 수정하는 방법을 소개합니다.\n\n\n\n\n\n\nJava 개발자로서 살다보면 자주는 아니지만\n이미 빌드가 완료된  JAR 파일의 바이트코드를 수정해야 하는 일이 생길 수 있다.\n(없다면 다행이고… 🙄)\n\n정말 피치 못할 사정때문에 해야한다면 아래 방법을 참고해보자.\n\n0. 🎬 사전 준비\n바이트코드를 수정할 수 있는 에디터 JBE를 준비한다.\n\n바이트코드 에디터는 여기 에서 다운로드 받는다.\n\n\n  \n    맥에서 jbe 실행방법은 터미널 해당 경로에서 아래와 같이 친다.\n  \n\n\n$ java -cp bin ee.ioc.cs.jbe.browser.BrowserApplication\n\n\n1. 🚧 JAR 라이브러리 압축 해제\n\n\n  JAR 파일의 확장자를 .zip 으로 변경 후 압축해제 하거나 콘솔에서 unzip 명령어로 압축을 푼다.\n\n\n\n  JAR 파일을 압축해제 해보면 Manifest와 .class파일로 구성되어 있다.\n\n\n2. 🛠️ 클래스파일 수정\n\n\n  \n    바이트코드 에디터로 압축해제한 파일에서 수정할 class 파일을 연다.\n  \n  \n    Methods &amp;gt; 수정할 함수이름 &amp;gt; [0] Code &amp;gt; Code Editor 탭으로 이동한다.\n  \n  \n    원하는 라인을 수정한다.\n  \n  \n    Save method 로 class 파일 저장한다.\n  \n\n\n\n  수정하는 방법은 아래의 Tip 항목을 참고해보자.\n\n\n3. 🤐 JAR 라이브러리 재압축\n\n  \n    압축해제한 최상위 경로의 com, META-INF을 다시 zip 파일로 압축한다.\n  \n  \n    zip 파일의 확장자를 .jar 로 수정한다.\n  \n\n\n\n  맥의 기본 압축프로그램을 사용 시 .DS_Store 와 __MACOSX 와 같은 파일이 첨부되므로 WinArchiveLite를 사용하거나 콘솔에서 zip 명령어로 직접 압축한다.\n\n\n+ 💁‍♂️ 바이트코드 수정하는 Tip\n바이트코드 명령어의 목록은 여기에서 확인할 수 있다.\n\n위키피디아 링크 : https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\n\n바이트코드 읽는 요령을 아주 간단히만 적자면 (간단할 수가 없지만..)\n\n명령어는 보통 {데이터형} + {명령코드(opcode)} 형태로 되어 있는데\n가령 예를들어 정수형 값을 저장한다면 istore, 객체를 저장한다면 astore\n만약 정수형 값을 불러온다면  iload, 객체를 불러온다면 aload 와 같은 식이다.\n또한 상수값의 경우는 iconst와 같이 const 를 이용하여 불러온다.\n\n가령 아래와 같이 Java 코드를 수정한다고 치자.\n\n\n  \n    \n      Before\n      After\n    \n  \n  \n    \n      return 1;\n      return 0;\n    \n  \n\n\n이를 Before 에서 After로 수정하고 싶다면 아래와 같이 bytecode를 수정하면 된다.\n\n\n  \n    \n      Before\n      After\n    \n  \n  \n    \n      iconst_1ireturn\n      iconst_0ireturn\n    \n  \n\n\n사실 일부사례를 더 적었으나…\n단순히 코드와 클래스파일이 정확하게 변형 되는 것이 아니라서\n상황에 따라서 틀릴 수 있는 내용이 포함되어 삭제했다… 😥\n\n바이트코드의 명령어의 정의를 찾아보면 좀 더 도움이 될 수 있다.\n"
} ,
  
  {
    "title"    : "Android APK 이름에 Git 리비전 태그 붙이기",
    "category" : "",
    "tags"     : " ",
    "url"      : "/android/2020/10/03/Tagging-git-on-APK.html",
    "date"     : "October 3, 2020",
    "excerpt"  : "Android APK 생성 시 APK 파일 이름에 Git 리비전 태그를 붙이는 방법을 설염합니다.\n\n안드로이드에서 처음 앱을 빌드하면 apk는 보통\n\napp-debug.apk 또는 app-release.apk\n\n가 보통 나옵니다.\n\n버전관리를 위해 APK 이름에 빌드 날짜와 git 리비전을 남기고 싶다면\n아래와 같이 작성해보세요.\n\n1. 앱 수준의 build.gradle(app)\n\n앱 수준의 build.gradle(app) 에서 andro...",
  "content"  : "Android APK 생성 시 APK 파일 이름에 Git 리비전 태그를 붙이는 방법을 설염합니다.\n\n안드로이드에서 처음 앱을 빌드하면 apk는 보통\n\napp-debug.apk 또는 app-release.apk\n\n가 보통 나옵니다.\n\n버전관리를 위해 APK 이름에 빌드 날짜와 git 리비전을 남기고 싶다면\n아래와 같이 작성해보세요.\n\n1. 앱 수준의 build.gradle(app)\n\n앱 수준의 build.gradle(app) 에서 android{ } 안에 아래와 같이 추가 하면 됩니다\n\nandroid {\n    ...\n    android.applicationVariants.all { variant -&amp;gt;\n        changeAPKName(variant)\n    }\n}\n\n\n2.  changeAPKName 함수 추가\n\n그 다음 android{ }밖에 changeAPKName 함수를 추가합니다.\n\ndef changeAPKName(variant) {\n    variant.outputs.all { output -&amp;gt;\n        def apkName = {\n            def appName = &#39;sample&#39;\n            def buildType = name.split(&#39;-&#39;).last() // debug or release\n            def currentDate = { return new Date().format(&#39;yyyyMMdd&#39;) }\n            def gitHash = { -&amp;gt;\n                def stdout = new ByteArrayOutputStream()\n                exec {\n                    commandLine &#39;git&#39;, &#39;rev-parse&#39;, &#39;--verify&#39;, &#39;--short&#39;, &#39;HEAD&#39;\n                    standardOutput = stdout\n                }\n                return stdout.toString().trim()\n            }\n            return &quot;${appName}_${buildType}_${currentDate()}_${gitHash()}.apk&quot;\n        }\n        outputFileName = new File(apkName())\n        logger.info(&#39;APK FILE NAME : &#39; + apkName())\n    }\n}\n\n\n그럼 아래와 같은 형식으로 바뀝니다.\n\n\n\n만약 다른 방식을 원한다면 changeAPKName 함수를 수정해보세요.\n"
} ,
  
  {
    "title"    : "신해나라의 2019년 회고",
    "category" : "",
    "tags"     : " ",
    "url"      : "/daily/2019/12/31/Reviewing_2019.html",
    "date"     : "December 31, 2019",
    "excerpt"  : "\n  2019년 한 해를 돌아봅니다\n\n\n신해나라의 2019년 회고\n\n🎉 2019년이 가고 2020년이 다가옵니다! 🎉\n\n2019년은 정말 👨개인적으로도, 👨‍💻개발자 커리어에 있어서도 큰 의미가 있는 한해였습니다.\n30대로서의 첫단추였고 아들의 첫 돌잔치도 있었고 부모님과 집을 합치고 개발자 행사에서 발표도 했습니다.\n😰 반년간 조급해만 하고, 😵 나머지 반년간 방황만 하고 🚏 방향에 대해 결정내리지 못한 일이 더 많았지만\n어떻게든 성장하...",
  "content"  : "\n  2019년 한 해를 돌아봅니다\n\n\n신해나라의 2019년 회고\n\n🎉 2019년이 가고 2020년이 다가옵니다! 🎉\n\n2019년은 정말 👨개인적으로도, 👨‍💻개발자 커리어에 있어서도 큰 의미가 있는 한해였습니다.\n30대로서의 첫단추였고 아들의 첫 돌잔치도 있었고 부모님과 집을 합치고 개발자 행사에서 발표도 했습니다.\n😰 반년간 조급해만 하고, 😵 나머지 반년간 방황만 하고 🚏 방향에 대해 결정내리지 못한 일이 더 많았지만\n어떻게든 성장하기 위해 발버둥 치면서 배운 것도 많다고 생각합니다.\n내년에는 좀 더 양보단 퀄리티 있는 성장에 집중하고자 합니다.\n아무튼 시작이 반이라고, 여러가지 의미있는 시작들이 꽤 있었습니다.\n\n👍 올해 잘한 일\n\n  코틀린으로 여러가지 프로젝트를 해보면서 많이 배웠습니다.\n  작은 프로젝트지만 오픈소스 프로젝트에 기여해 보았습니다.\n  비록 세달뿐이지만 꾸준이 GitHub 잔디밭 관리를 했습니다.🌱\n  데이터바인딩과 MVVM 패턴을 혼자서 학습했습니다.\n  테스트코드를 작성해보았습니다.\n  개인 🤖 안드로이드 프로젝트를 몇가지 해보았습니다.\n  올 한해 동안만 27개의 개발자 행사를 참석했습니다.\n  그동안 다녀온 개발자 행사를 깃헙으로 정리했습니다.\n  개발자 행사에서 처음으로 발표를 해보았습니다.\n  💵 청년내일채움공제를 드디어 마쳤습니다.\n  Github 활용도가 많이 늘었습니다.\n  부모님과 집을 합친 것은 정말 백번 잘한 일이었습니다.\n  이모지를 많이 활용하게 되었습니다.😀\n\n\n👎 올해 아쉬운 일\n\n\n  술 먹고 닌텐도 스위치를 잃어버렸습니다…😭\n  안드로이드 UI테스트를 해보지 못했습니다.\n  RxJava, 코루틴, Dagger 등 아직 배워야할 것이 더 많습니다.\n  연말에 번아웃으로 회사 업무에 집중력이 많이 떨어졌습니다.😵\n  Github를 좀 더 빨리 시작하지 못한 것이 아쉽습니다. 7월에 첫시작했을 때부터 꾸준히 했으면 좋았을 걸…\n  블로그 운영을 해보지 못했습니다. 블로그 운영방향에 대해 아직 결정을 못해서긴 하지만..\n  책을 사놓기만 하고 얼마 읽지 못했습니다.\n  마스터 이력서를 제대로 정리하지 못했습니다.\n  코틀린을 좀 더 깊이 학습할 필요가 있을 것 같습니다.\n  AWS와 Spring, Node.js 등 백엔드 학습의 필요성만 느끼고 실제로는 손도 못댔습니다.\n\n\n👏 총평\n\n🤔 안드로이드 개발 2년차로서 올한해 성장한 것에 80% 정도 만족스럽다.\n\n👨‍🎓 아직도 배워야 할 것이 많고 더 많이 배워야 하겠지만\n순서와 방향에 대해서는 아직도 고민이 많습니다. 💭\n이직에 대한 조급함 때문에 시야가 오히려 더 좁아진 건 아닌가 반성합니다.🏇\n기술의 학습도 당연히 필요하지만, 너무 그 기술자체에 끌려다니지 않으려고 노력한 것은 좋지만\n정작 중요한 ‘내공’을 쌓았는가? 라고 말한다면 그렇지도 못한 것 같습니다.\n🎯 내년에는 이 추상적인 ‘내공’을 측정가능한 목표로서 설정하고 달성할 필요가 있겠습니다.\n\n올 한해 많은 것을 배울 수 있도록 물신양면으로 지원해준 아내와 부모님,\n그리고 건강하게 자라준 우리 새미찬에게 늘 감사하고 사랑합니다.💗\n"
} 
  
  ,
  
  {
  
  "title"    : "Ninja",
  "category" : "",
  "tags"     : " Lorem",
  "url"      : "/portfolio/ninja",
  "date"     : "April 8, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Creative",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/safe",
  "date"     : "August 16, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Circus",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/circus",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tower of Hanoi",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/hanoi",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tic tac toe",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/tictactoe",
  "date"     : "September 1, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Cake",
  "category" : "",
  "tags"     : " Lorem, Ipsum, Portfolio",
  "url"      : "/portfolio/cake",
  "date"     : "September 27, 2015",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Jekyll",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/jekyllblog",
  "date"     : "May 26, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Lorem Ipsum",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/submarine",
  "date"     : "September 3, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n\n"
  
} ,
  
  {
  
  "title"    : "Github",
  "category" : "",
  "tags"     : " Lorem, Portfolio",
  "url"      : "/portfolio/gitlecture",
  "date"     : "October 20, 2017",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} 
  
]
